#!/usr/bin/env nix-shell
#!nix-shell -i python3 -p python3 -p python3.pkgs.natsort -p python3.pkgs.requests
# vim: set filetype=python :
"""
usage: sane-bt-search [options] <query_string>

searches Jackett for torrent files matching the title.
returns select results and magnet links.
"""

# about Jackett
# - source: <https://github.com/Jackett/Jackett>
# - can be queried via APIs:
#   - Torznab: <https://torznab.github.io/spec-1.3-draft/index.html>
#   - TorrentPotato: <https://github.com/RuudBurger/CouchPotatoServer/wiki/Couchpotato-torrent-provider>
#   - its own JSON-based API
#
# about BitMagnet:
# - source: <https://github.com/bitmagnet-io/bitmagnet>
# - DHT crawler/indexer
# - can be queried via torznab API:
#   - `curl http://10.0.1.6:3333/torznab/api/?t=search`
#
# about torrent jargon:
# - <https://en.wikipedia.org/wiki/Pirated_movie_release_types>

from dataclasses import dataclass
from datetime import datetime
from enum import Enum, IntEnum
import argparse
import logging
import json
import natsort
import requests
import sys
import time

SERVICE = "https://jackett.uninsane.org"
ENDPOINTS = dict(
    results="api/v2.0/indexers/all/results"
    # results_torznab="api/v2.0/indexers/all/results/torznab"
)

DEFAULT_RESULT_COUNT = 12

epoch = datetime(1970, 1, 1)

logger = logging.getLogger(__name__)

class SortMethod(Enum):
    Balanced = "balanced"
    Seeders = "seeders"
    Size = "size"
    Tracker = "tracker"

    def __str__(self) -> str:
        # for argparse `--help` message
        return self.value

class TrackerQuality(IntEnum):
    Authoritative = 0
    Trustworthy = 1
    Good = 2
    Mediocre = 3
    Bad = 4
    Unknown = 5

class BadCliArgs(Exception):
    def __init__(self, msg: str | None = None) -> None:
        helpstr = __doc__
        if msg:
            super().__init__(f"{msg}\n\n{helpstr}")
        else:
            super().__init__(helpstr)


def try_parse_time(t: str) -> datetime:
    try:
        return datetime.fromisoformat(t)
    except ValueError: pass

    if len(t) > len('YYYY-MM-DD'):
        # sometimes these timestamps are encoded with e.g. too many digits in the milliseconds field.
        # so just keep chomping until we get something that parses as a timestamp
        return try_parse_time(t[:-1])

def parse_time(t: str) -> datetime:
    return try_parse_time(t).astimezone() or epoch

@dataclass(eq=True, order=True, unsafe_hash=True)
class Tracker:
    id_: str
    name: str
    # preference: major, minor.
    # lower value = more preferable.
    # trackers with the same major are on a similar "tier"
    quality: TrackerQuality
    order: int

    @staticmethod
    def by_id(id_: str) -> 'Tracker':
        if id_ in KNOWN_TRACKERS:
            return KNOWN_TRACKERS[id_]
        logger.warning(f"unknown tracker: {id_!r}")
        return Tracker(id_, TrackerQuality.Unknown, len(KNOWN_TRACKERS))

    def __repr__(self) -> str:
        return self.id_

def _KNOWN_TRACKERS() -> dict[str, Tracker]:
    trackers = {}

    order = 0
    def add_tracker(*args):
        nonlocal order
        t = Tracker(*args, order)
        order += 1
        trackers[t.id_] = t

    # the order of this list (even within sections) is significant:
    # most preferred -> least preferred
    add_tracker('bitmagnet', 'BitMagnet (Local DHT)', TrackerQuality.Authoritative)

    add_tracker('bakabt', 'BakaBT', TrackerQuality.Trustworthy)
    add_tracker('subsplease', 'SubsPlease', TrackerQuality.Trustworthy)
    add_tracker('nyaasi', 'Nyaa.si', TrackerQuality.Trustworthy)
    add_tracker('sukebeinyaasi', 'sukebei.nyaa.si', TrackerQuality.Trustworthy)

    add_tracker('yts', 'YTS', TrackerQuality.Good)
    add_tracker('tokyotosho', 'Tokyo Toshokan', TrackerQuality.Good)

    add_tracker('internetarchive', 'Internet Archive', TrackerQuality.Mediocre)
    add_tracker('thepiratebay', 'The Pirate Bay', TrackerQuality.Mediocre)
    add_tracker('miobt', 'MioBT', TrackerQuality.Mediocre)
    add_tracker('bangumi-moe', 'Bangumi Moe', TrackerQuality.Mediocre)
    add_tracker('torlock', 'Torlock', TrackerQuality.Mediocre)

    add_tracker('1337x', '1337x', TrackerQuality.Bad)
    add_tracker('kickasstorrents-to', 'kickasstorrents.to', TrackerQuality.Bad)

    return trackers

KNOWN_TRACKERS = _KNOWN_TRACKERS()

DROP_CATS = { "dvd", "hd", "misc", "other", "sd", "uhd" }
BOOK_CATS = { "audio", "books", "ebook" }
MANGA_CATS = { "books", "comics", "ebook" }
VIDEO_CATS = { "anime", "movies", "tv" }
KNOWN_CATS = frozenset(
    list(BOOK_CATS) +
    list(MANGA_CATS) +
    list(VIDEO_CATS) +
    ["xxx"]
)
def clean_cat(c: str) -> str | None:
    if c in DROP_CATS: return None
    return c

def is_cat(cats: list[str], wanted_cats: list[str], default: bool = False) -> bool:
    """
    return True if any of the `cats` is in `wanted_cats`.
    in the event there no category is recognized, assume `default`
    """
    if not any(c in KNOWN_CATS for c in cats):
        return default
    else:
        return any(c in wanted_cats for c in cats)

H265_MARKERS = {
    "H265",
    "H.265",
    "x265",
    "x.265",
    "HEVC",
}

class Filter:
    def __init__(self, book: bool=False, h265: bool=False, manga: bool=False, video: bool=False):
        self.book = book
        self.h265 = h265
        self.manga = manga
        self.video = video

    def filter(self, torrents: list['Torrent']) -> list['Torrent']:
        return [t for t in torrents if self.is_match(t)]

    def is_match(self, t: 'Torrent', default: bool = False) -> bool:
        valid = True
        valid = valid and (not self.book or self.is_book(t, default))
        valid = valid and (not self.h265 or self.is_h265(t))
        valid = valid and (not self.manga or self.is_manga(t, default))
        valid = valid and (not self.video or self.is_video(t, default))
        return valid

    @staticmethod
    def is_h265(t: 'Torrent') -> bool:
        return any(tag.lower() in t.title.lower() for tag in H265_MARKERS)

    @staticmethod
    def is_book(t: 'Torrent', default: bool = False) -> bool:
        return is_cat(t.categories, BOOK_CATS, default)

    @staticmethod
    def is_manga(t: 'Torrent', default: bool = False) -> bool:
        return is_cat(t.categories, MANGA_CATS, default)

    @staticmethod
    def is_video(t: 'Torrent', default: bool = False) -> bool:
        return is_cat(t.categories, VIDEO_CATS, default)


@dataclass(eq=True, order=True, unsafe_hash=True)
class Torrent:
    seeders: int
    pub_date: datetime
    size: int
    tracker: Tracker
    title: str
    info_hash: str | None
    magnet: str | None
    http_dl_uri: str | None  # probably a .torrent file but it COULD be a referral to a magnet:// URI
    tracker_uri: str | None
    categories: frozenset[str]  # human-friendly list of categories, lowercase. e.g. ["Books", "Anime"]

    def __str__(self) -> str:
        cats = "/".join(self.categories) if self.categories else "?"
        rows = []
        rows.append(f"{self.seeders}[S]\t{cats}\t{self.tracker}\t{self.pub_date}\t{self.mib}M\t{self.title}")
        if self.tracker_uri:
            rows.append(f"\t{self.tracker_uri}")
        rows.append(f"\t{self.dl_uri}")
        return "\n".join(rows)

    @property
    def dl_uri(self) -> str | None:
        return self.magnet or self.http_dl_uri

    @property
    def mib(self) -> int:
        return int(round(self.size / 1024 / 1024))

    @staticmethod
    def from_dict(d: dict) -> 'Torrent':
        logger.debug(f"Torrent.from_dict: fields: { ' '.join(d.keys()) }")
        for k, v in d.items():
            if k not in (
                "CategoryDesc",
                "Details",
                "Guid",
                "InfoHash",
                "Link",
                "MagnetUri",
                "PublishDate",
                "Seeders",
                "Size",
                "Title",
                "TrackerId",
            ) and v != None and v != "" and v != [] and v != {}:
                logger.debug(f"  {k} = {v}")

        seeders = d.get("Seeders")
        pub_date = d.get("PublishDate")
        size = d.get("Size")
        tracker_id = d.get("TrackerId")
        title = d.get("Title")
        info_hash = d.get("InfoHash")
        magnet = d.get("MagnetUri") or d.get("Guid")
        http_dl_uri = d.get("Link")
        tracker_uri = d.get("Details")
        categories = d.get("CategoryDesc", "").replace("/", ",").split(",")
        categories = (c.strip().lower() for c in categories)
        categories = frozenset(clean_cat(c) for c in categories if clean_cat(c))

        if magnet and not magnet.startswith("magnet:"):
            logger.info(f"invalid magnet: {magnet}")
            magnet = None

        if http_dl_uri:
            # quirk: jackett responds with port number even if it's a default port number
            # it still works, just adds noise to the output
            http_dl_uri = http_dl_uri.replace('https://jackett.uninsane.org:443/', 'https://jackett.uninsane.org/')

        if tracker_uri:
            # quirk: bakabt's post-login redirection fails if the slashes aren't just right
            tracker_uri = tracker_uri.replace('https://bakabt.me//', 'https://bakabt.me/')
            # quirk: bitmagnet doesn't populate the torrent page, except as a link to the website homepage.
            # - tracking issue: <https://github.com/bitmagnet-io/bitmagnet/issues/375>
            #   - see open PRs for immediate fix
            # quirk: Jackett can't parse bitmagnet's `torznab:seeders`/leechers field:
            # - <https://github.com/Jackett/Jackett/issues/15126#issuecomment-1996342455>
            if tracker_uri == 'http://10.0.1.6:3333/':
                tracker_uri = f"https://bitmagnet.uninsane.org/webui/torrents/permalink/{info_hash}"

        if seeders is not None and pub_date is not None and title is not None and (magnet is not None or http_dl_uri is not None):
            pub_date = parse_time(pub_date)
            return Torrent(
                seeders=seeders,
                pub_date=pub_date,
                size=size,
                tracker=Tracker.by_id(tracker_id),
                title=title,
                info_hash=info_hash,
                magnet=magnet,
                http_dl_uri=http_dl_uri,
                tracker_uri=tracker_uri,
                categories=categories,
            )

    def to_dict(self) -> dict:
        # N.B.: not all fields: needs to be kept in sync with consumers like mx-sanebot
        return dict(
            seeders=self.seeders,
            pub_date=self.pub_date.strftime("%Y-%m-%d"),
            size=self.size,
            tracker=self.tracker,
            title=self.title,
            magnet=self.magnet,
        )

class Client:
    def __init__(self):
        self.apikey = open("/run/secrets/jackett_apikey").read().strip()

    def api_call(self, method: str, params: dict) -> dict:
        endpoint = ENDPOINTS[method]
        url = f"{SERVICE}/{endpoint}"
        params = params.copy()
        logger.debug(f"GET {url!r} with payload: {params}")
        params.update(apikey=self.apikey, _=str(int(time.time())))
        resp = requests.get(url, params=params)
        text = str(resp.text)
        try:
            return json.loads(text)
        except Exception as e:
            logger.error(f"failed to parse json API response from {url}: {text}")
            raise e

    def query(self, query: str, trackers: list[str] | None) -> list[Torrent]:
        torrents = set()
        params = {}
        params["Query"] = query
        if trackers is not None:
            params["Tracker[]"] = trackers
        api_res = self.api_call("results", params)
        for r in api_res["Results"]:
            t = Torrent.from_dict(r)
            if t is not None:
                torrents.add(t)

        return sorted(torrents, reverse=True)

def sort_results(torrents: list[Torrent], by: SortMethod) -> list[Torrent]:
    def key(t: Torrent) -> tuple[int, int, Torrent]:
        rank_seeders = -t.seeders
        rank_size = -t.size
        # TODO: `Balanced` should consider `size` and `pub_date`
        return {
            SortMethod.Balanced: (t.tracker.quality, rank_seeders, t.tracker.order, rank_size, t),
            SortMethod.Seeders: (rank_seeders, t.tracker.quality, t.tracker.order, rank_size, t),
            SortMethod.Size: (rank_size, t.tracker.quality, rank_seeders, t.tracker.order, t),
            SortMethod.Tracker: (t.tracker.quality, t.tracker.order, rank_seeders, rank_size, t),
        }[by]
    return sorted(torrents, key=key)

def format_results(all_results: list[Torrent], filtered_results: list[Torrent], json: bool):
    if json:
        dumpable = [t.to_dict() for t in filtered_results]
        print(json.dumps(dumpable))
    else:
        num_total = len(all_results)
        num_filtered = len(filtered_results)
        print(f"found {num_total} result(s) filtered to {num_filtered}")
        for r in filtered_results:
            print(r)

def main(args: list[str]):
    logging.basicConfig()
    logging.getLogger().setLevel(logging.WARNING)

    parser = argparse.ArgumentParser(description='search torrent trackers')
    parser.add_argument('--full', action='store_true', help='show all results')
    parser.add_argument('--top', help=f'how many results to show (default: {DEFAULT_RESULT_COUNT})')
    parser.add_argument('--sort-by', default=SortMethod.Balanced, type=SortMethod, choices=SortMethod, help='how to rank matches (seeders, tracker)')
    parser.add_argument('--json', action='store_true', help='output results in json')
    parser.add_argument('--tracker', type=str, action='append', help='query only this tracker(s)', choices=KNOWN_TRACKERS.keys())
    parser.add_argument('--verbose', action='store_true')
    parser.add_argument('--book', action='store_true', help='show only book (ebook or audiobook) results')
    parser.add_argument('--h265', action='store_true', help='show only H.265/HEVC results (might cause false negatives)')
    parser.add_argument('--manga', action='store_true', help='show only manga results')
    parser.add_argument('--video', action='store_true', help='show only video (tv or film)')
    parser.add_argument("query", help="text to search for in torrent titles/descriptions")

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    client = Client()
    all_results = client.query(args.query, args.tracker)

    filter = Filter(book=args.book, h265=args.h265, manga=args.manga, video=args.video)
    filtered_results = filter.filter(all_results)
    ordered_results = sort_results(filtered_results, args.sort_by)

    if not args.full:
        ordered_results = ordered_results[:int(args.top or str(DEFAULT_RESULT_COUNT))]

    format_results(all_results, ordered_results, args.json)

if __name__ == "__main__":
    main(sys.argv[1:])
