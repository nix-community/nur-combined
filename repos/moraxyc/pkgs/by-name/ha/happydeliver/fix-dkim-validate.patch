diff --git a/pkg/analyzer/authentication.go b/pkg/analyzer/authentication.go
index 07f7794..b814e57 100644
--- a/pkg/analyzer/authentication.go
+++ b/pkg/analyzer/authentication.go
@@ -42,7 +42,7 @@ func (a *AuthenticationAnalyzer) AnalyzeAuthentication(email *EmailMessage) *api
 	// Parse Authentication-Results headers
 	authHeaders := email.GetAuthenticationResults()
 	for _, header := range authHeaders {
-		a.parseAuthenticationResultsHeader(header, results)
+		a.parseAuthenticationResultsHeader(header, results, email)
 	}
 
 	// If no Authentication-Results headers, try to parse legacy headers
@@ -63,7 +63,7 @@ func (a *AuthenticationAnalyzer) AnalyzeAuthentication(email *EmailMessage) *api
 
 // parseAuthenticationResultsHeader parses an Authentication-Results header
 // Format: example.com; spf=pass smtp.mailfrom=sender@example.com; dkim=pass header.d=example.com
-func (a *AuthenticationAnalyzer) parseAuthenticationResultsHeader(header string, results *api.AuthenticationResults) {
+func (a *AuthenticationAnalyzer) parseAuthenticationResultsHeader(header string, results *api.AuthenticationResults, email *EmailMessage) {
 	// Split by semicolon to get individual results
 	parts := strings.Split(header, ";")
 	if len(parts) < 2 {
@@ -86,7 +86,7 @@ func (a *AuthenticationAnalyzer) parseAuthenticationResultsHeader(header string,
 
 		// Parse DKIM
 		if strings.HasPrefix(part, "dkim=") {
-			dkimResult := a.parseDKIMResult(part)
+			dkimResult := a.parseDKIMResult(part, email)
 			if dkimResult != nil {
 				if results.Dkim == nil {
 					dkimList := []api.AuthResult{*dkimResult}
diff --git a/pkg/analyzer/authentication_dkim.go b/pkg/analyzer/authentication_dkim.go
index b6cf5f8..0cd96b4 100644
--- a/pkg/analyzer/authentication_dkim.go
+++ b/pkg/analyzer/authentication_dkim.go
@@ -22,15 +22,36 @@
 package analyzer
 
 import (
+	"net/textproto"
 	"regexp"
 	"strings"
 
 	"git.happydns.org/happyDeliver/internal/api"
 )
 
+// parseDKIMSelectorFromSignature extracts the selector from DKIM-Signature header
+func parseDKIMSelectorFromSignature(email *EmailMessage) string {
+	if email == nil {
+		return ""
+	}
+
+	dkimHeaders := email.Header[textproto.CanonicalMIMEHeaderKey("DKIM-Signature")]
+	if len(dkimHeaders) == 0 {
+		return ""
+	}
+
+	dkimHeader := dkimHeaders[0]
+	re := regexp.MustCompile(`\bs=([^\s;]+)`)
+	if matches := re.FindStringSubmatch(dkimHeader); len(matches) > 1 {
+		return matches[1]
+	}
+
+	return ""
+}
+
 // parseDKIMResult parses DKIM result from Authentication-Results
 // Example: dkim=pass header.d=example.com header.s=selector1
-func (a *AuthenticationAnalyzer) parseDKIMResult(part string) *api.AuthResult {
+func (a *AuthenticationAnalyzer) parseDKIMResult(part string, email *EmailMessage) *api.AuthResult {
 	result := &api.AuthResult{}
 
 	// Extract result (pass, fail, etc.)
@@ -52,6 +73,12 @@ func (a *AuthenticationAnalyzer) parseDKIMResult(part string) *api.AuthResult {
 	if matches := selectorRe.FindStringSubmatch(part); len(matches) > 1 {
 		selector := matches[1]
 		result.Selector = &selector
+	} else {
+		// If selector not found in Authentication-Results, try to extract from DKIM-Signature header
+		selector := parseDKIMSelectorFromSignature(email)
+		if selector != "" {
+			result.Selector = &selector
+		}
 	}
 
 	result.Details = api.PtrTo(strings.TrimPrefix(part, "dkim="))
diff --git a/pkg/analyzer/authentication_dkim_test.go b/pkg/analyzer/authentication_dkim_test.go
index 2aab530..2cdbced 100644
--- a/pkg/analyzer/authentication_dkim_test.go
+++ b/pkg/analyzer/authentication_dkim_test.go
@@ -22,6 +22,8 @@
 package analyzer
 
 import (
+	"net/mail"
+	"net/textproto"
 	"testing"
 
 	"git.happydns.org/happyDeliver/internal/api"
@@ -62,7 +64,7 @@ func TestParseDKIMResult(t *testing.T) {
 
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
-			result := analyzer.parseDKIMResult(tt.part)
+			result := analyzer.parseDKIMResult(tt.part, nil)
 
 			if result.Result != tt.expectedResult {
 				t.Errorf("Result = %v, want %v", result.Result, tt.expectedResult)
@@ -84,3 +86,124 @@ func TestParseDKIMResult(t *testing.T) {
 		})
 	}
 }
+
+func TestParseDKIMResultWithSignatureHeader(t *testing.T) {
+	tests := []struct {
+		name             string
+		part             string
+		dkimSignature    string
+		expectedResult   api.AuthResultResult
+		expectedDomain   string
+		expectedSelector string
+	}{
+		{
+			name:             "DKIM pass with domain, selector from DKIM-Signature header",
+			part:             "dkim=pass header.d=gitlab.dn42 header.i=@gitlab.dn42",
+			dkimSignature:    "v=1; a=rsa-sha256; c=relaxed/relaxed; d=gitlab.dn42; s=default; t=1234567890;",
+			expectedResult:   api.AuthResultResultPass,
+			expectedDomain:   "gitlab.dn42",
+			expectedSelector: "default",
+		},
+		{
+			name:             "DKIM pass with domain, no selector in both, should not crash",
+			part:             "dkim=pass header.d=example.com",
+			dkimSignature:    "v=1; a=rsa-sha256; c=relaxed/relaxed; d=example.com; t=1234567890;",
+			expectedResult:   api.AuthResultResultPass,
+			expectedDomain:   "example.com",
+			expectedSelector: "",
+		},
+		{
+			name:             "DKIM pass, selector in Auth-Results takes precedence over DKIM-Signature",
+			part:             "dkim=pass header.d=example.com header.s=selector1",
+			dkimSignature:    "v=1; a=rsa-sha256; c=relaxed/relaxed; d=example.com; s=default; t=1234567890;",
+			expectedResult:   api.AuthResultResultPass,
+			expectedDomain:   "example.com",
+			expectedSelector: "selector1",
+		},
+	}
+
+	analyzer := NewAuthenticationAnalyzer()
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			email := &EmailMessage{
+				Header: mail.Header{},
+			}
+			if tt.dkimSignature != "" {
+				email.Header[textproto.CanonicalMIMEHeaderKey("DKIM-Signature")] = []string{tt.dkimSignature}
+			}
+
+			result := analyzer.parseDKIMResult(tt.part, email)
+
+			if result.Result != tt.expectedResult {
+				t.Errorf("Result = %v, want %v", result.Result, tt.expectedResult)
+			}
+			if result.Domain == nil || *result.Domain != tt.expectedDomain {
+				var gotDomain string
+				if result.Domain != nil {
+					gotDomain = *result.Domain
+				}
+				t.Errorf("Domain = %v, want %v", gotDomain, tt.expectedDomain)
+			}
+			if tt.expectedSelector != "" {
+				if result.Selector == nil || *result.Selector != tt.expectedSelector {
+					var gotSelector string
+					if result.Selector != nil {
+						gotSelector = *result.Selector
+					}
+					t.Errorf("Selector = %v, want %v", gotSelector, tt.expectedSelector)
+				}
+			} else {
+				if result.Selector != nil {
+					t.Errorf("Selector should be nil, got %v", *result.Selector)
+				}
+			}
+		})
+	}
+}
+
+func TestParseDKIMSelectorFromSignature(t *testing.T) {
+	tests := []struct {
+		name      string
+		signature string
+		expected  string
+	}{
+		{
+			name:      "Selector in middle of signature",
+			signature: "v=1; a=rsa-sha256; c=relaxed/relaxed; d=gitlab.dn42; s=default; t=1234567890;",
+			expected:  "default",
+		},
+		{
+			name:      "Selector at end of signature",
+			signature: "v=1; a=rsa-sha256; d=example.com; s=selector1",
+			expected:  "selector1",
+		},
+		{
+			name:      "No selector in signature",
+			signature: "v=1; a=rsa-sha256; d=example.com; t=1234567890;",
+			expected:  "",
+		},
+		{
+			name:      "Empty signature",
+			signature: "",
+			expected:  "",
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			email := &EmailMessage{
+				Header: mail.Header{},
+			}
+			if tt.signature != "" {
+				email.Header[textproto.CanonicalMIMEHeaderKey("DKIM-Signature")] = []string{tt.signature}
+			}
+
+			result := parseDKIMSelectorFromSignature(email)
+
+			if result != tt.expected {
+				t.Errorf("parseDKIMSelectorFromSignature() = %v, want %v", result, tt.expected)
+			}
+		})
+	}
+}
diff --git a/pkg/analyzer/authentication_iprev_test.go b/pkg/analyzer/authentication_iprev_test.go
index d0529b5..96a9b59 100644
--- a/pkg/analyzer/authentication_iprev_test.go
+++ b/pkg/analyzer/authentication_iprev_test.go
@@ -186,7 +186,7 @@ func TestParseAuthenticationResultsHeader_IPRev(t *testing.T) {
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			results := &api.AuthenticationResults{}
-			analyzer.parseAuthenticationResultsHeader(tt.header, results)
+			analyzer.parseAuthenticationResultsHeader(tt.header, results, nil)
 
 			// Check IPRev
 			if tt.expectedIPRevResult != nil {
diff --git a/pkg/analyzer/authentication_test.go b/pkg/analyzer/authentication_test.go
index 27901b5..7aaf086 100644
--- a/pkg/analyzer/authentication_test.go
+++ b/pkg/analyzer/authentication_test.go
@@ -252,7 +252,7 @@ func TestParseAuthenticationResultsHeader(t *testing.T) {
 	for _, tt := range tests {
 		t.Run(tt.name, func(t *testing.T) {
 			results := &api.AuthenticationResults{}
-			analyzer.parseAuthenticationResultsHeader(tt.header, results)
+			analyzer.parseAuthenticationResultsHeader(tt.header, results, nil)
 
 			// Check SPF
 			if tt.expectedSPFResult != nil {
@@ -358,7 +358,7 @@ func TestParseAuthenticationResultsHeader_OnlyFirstResultParsed(t *testing.T) {
 	t.Run("Multiple SPF results - only first is parsed", func(t *testing.T) {
 		header := "mail.example.com; spf=pass smtp.mailfrom=first@example.com; spf=fail smtp.mailfrom=second@example.com"
 		results := &api.AuthenticationResults{}
-		analyzer.parseAuthenticationResultsHeader(header, results)
+		analyzer.parseAuthenticationResultsHeader(header, results, nil)
 
 		if results.Spf == nil {
 			t.Fatal("Expected SPF result, got nil")
@@ -374,7 +374,7 @@ func TestParseAuthenticationResultsHeader_OnlyFirstResultParsed(t *testing.T) {
 	t.Run("Multiple DMARC results - only first is parsed", func(t *testing.T) {
 		header := "mail.example.com; dmarc=pass header.from=first.com; dmarc=fail header.from=second.com"
 		results := &api.AuthenticationResults{}
-		analyzer.parseAuthenticationResultsHeader(header, results)
+		analyzer.parseAuthenticationResultsHeader(header, results, nil)
 
 		if results.Dmarc == nil {
 			t.Fatal("Expected DMARC result, got nil")
@@ -390,7 +390,7 @@ func TestParseAuthenticationResultsHeader_OnlyFirstResultParsed(t *testing.T) {
 	t.Run("Multiple ARC results - only first is parsed", func(t *testing.T) {
 		header := "mail.example.com; arc=pass; arc=fail"
 		results := &api.AuthenticationResults{}
-		analyzer.parseAuthenticationResultsHeader(header, results)
+		analyzer.parseAuthenticationResultsHeader(header, results, nil)
 
 		if results.Arc == nil {
 			t.Fatal("Expected ARC result, got nil")
@@ -403,7 +403,7 @@ func TestParseAuthenticationResultsHeader_OnlyFirstResultParsed(t *testing.T) {
 	t.Run("Multiple BIMI results - only first is parsed", func(t *testing.T) {
 		header := "mail.example.com; bimi=pass header.d=first.com; bimi=fail header.d=second.com"
 		results := &api.AuthenticationResults{}
-		analyzer.parseAuthenticationResultsHeader(header, results)
+		analyzer.parseAuthenticationResultsHeader(header, results, nil)
 
 		if results.Bimi == nil {
 			t.Fatal("Expected BIMI result, got nil")
@@ -420,7 +420,7 @@ func TestParseAuthenticationResultsHeader_OnlyFirstResultParsed(t *testing.T) {
 		// DKIM is special - multiple signatures should all be collected
 		header := "mail.example.com; dkim=pass header.d=first.com header.s=s1; dkim=fail header.d=second.com header.s=s2"
 		results := &api.AuthenticationResults{}
-		analyzer.parseAuthenticationResultsHeader(header, results)
+		analyzer.parseAuthenticationResultsHeader(header, results, nil)
 
 		if results.Dkim == nil {
 			t.Fatal("Expected DKIM results, got nil")
