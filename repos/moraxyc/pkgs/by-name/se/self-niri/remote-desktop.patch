diff --git a/Cargo.lock b/Cargo.lock
index 34b2a14a..12d19fde 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -2178,6 +2178,7 @@ dependencies = [
  "clap_complete_nushell",
  "directories",
  "drm-ffi",
+ "enumflags2",
  "fastrand",
  "futures-util",
  "git-version",
@@ -2200,6 +2201,7 @@ dependencies = [
  "proptest",
  "proptest-derive",
  "rayon",
+ "reis",
  "sd-notify",
  "serde",
  "serde_json",
@@ -3127,6 +3129,17 @@ version = "0.8.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7a2d987857b319362043e95f5353c0535c1f58eec5336fdfcf626430af7def58"
 
+[[package]]
+name = "reis"
+version = "0.5.0"
+source = "git+https://github.com/ids1024/reis#144099b9a0af6056c8865e0257ae37a8f6695e85"
+dependencies = [
+ "calloop 0.14.3",
+ "enumflags2",
+ "log",
+ "rustix 1.1.3",
+]
+
 [[package]]
 name = "rustc-hash"
 version = "2.1.1"
diff --git a/Cargo.toml b/Cargo.toml
index 622478e4..d1deecf7 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -61,6 +61,7 @@ async-channel = "2.5.0"
 async-io = { version = "2.6.0", optional = true }
 atomic = "0.6.1"
 bitflags.workspace = true
+enumflags2 = { version = "0.7.12", features = ["serde"] }
 bytemuck = { version = "1.24.0", features = ["derive"] }
 calloop = { version = "0.14.3", features = ["executor", "futures-io", "signals"] }
 clap = { workspace = true, features = ["string"] }
@@ -96,6 +97,7 @@ wayland-backend = "0.3.12"
 wayland-scanner = "0.31.8"
 xcursor = "0.3.10"
 zbus = { version = "5.13.0", optional = true }
+reis = { git = "https://github.com/ids1024/reis", features = ["calloop"], optional = true }
 
 [dependencies.smithay]
 workspace = true
@@ -129,13 +131,15 @@ xshell = "0.2.7"
 pkg-config = "0.3.32"
 
 [features]
-default = ["dbus", "systemd", "xdp-gnome-screencast"]
+default = ["dbus", "systemd", "xdp-gnome-screencast", "xdp-gnome-remote-desktop"]
 # Enables D-Bus support (serve various freedesktop and GNOME interfaces, accessibility tree, power button handling).
 dbus = ["dep:zbus", "dep:async-io", "dep:accesskit", "dep:accesskit_unix"]
 # Enables systemd integration (global environment, apps in transient scopes).
 systemd = ["dbus"]
 # Enables screencasting support through xdg-desktop-portal-gnome.
 xdp-gnome-screencast = ["dbus", "pipewire"]
+# Enables Remote Desktop portal support through xdg-desktop-portal-gnome.
+xdp-gnome-remote-desktop = ["dbus", "reis"]
 # Enables the Tracy profiler instrumentation.
 profile-with-tracy = ["profiling/profile-with-tracy", "tracy-client/default", "smithay/tracy_gpu_profiling"]
 # Enables the on-demand Tracy profiler instrumentation.
diff --git a/src/backend/mod.rs b/src/backend/mod.rs
index 49fbc6b0..d53d9c0f 100644
--- a/src/backend/mod.rs
+++ b/src/backend/mod.rs
@@ -20,6 +20,7 @@ pub use winit::Winit;
 pub mod headless;
 pub use headless::Headless;
 
+/// The backend for input events and graphical output.
 #[allow(clippy::large_enum_variant)]
 pub enum Backend {
     Tty(Tty),
diff --git a/src/dbus/mod.rs b/src/dbus/mod.rs
index 5941456f..f870f363 100644
--- a/src/dbus/mod.rs
+++ b/src/dbus/mod.rs
@@ -17,6 +17,11 @@ pub mod mutter_screen_cast;
 #[cfg(feature = "xdp-gnome-screencast")]
 use mutter_screen_cast::ScreenCast;
 
+#[cfg(feature = "xdp-gnome-remote-desktop")]
+pub mod mutter_remote_desktop;
+#[cfg(feature = "xdp-gnome-remote-desktop")]
+use mutter_remote_desktop::RemoteDesktop;
+
 use self::freedesktop_a11y::KeyboardMonitor;
 use self::freedesktop_screensaver::ScreenSaver;
 use self::gnome_shell_introspect::Introspect;
@@ -39,6 +44,8 @@ pub struct DBusServers {
     pub conn_login1: Option<Connection>,
     pub conn_locale1: Option<Connection>,
     pub conn_keyboard_monitor: Option<Connection>,
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    pub conn_remote_desktop: Option<Connection>,
 }
 
 impl DBusServers {
@@ -116,6 +123,31 @@ impl DBusServers {
             let introspect = Introspect::new(to_niri, from_niri);
             dbus.conn_introspect = try_start(introspect);
 
+            #[cfg(all(feature = "xdp-gnome-screencast", feature = "xdp-gnome-remote-desktop"))]
+            let remote_desktop_shared =
+                mutter_remote_desktop::shared::RemoteDesktopShared::new_arc_mutex();
+
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            {
+                let (to_niri, from_remote_desktop) = calloop::channel::channel();
+                niri.event_loop
+                    .insert_source(from_remote_desktop, {
+                        move |event, _, state| match event {
+                            calloop::channel::Event::Msg(msg) => {
+                                state.on_remote_desktop_msg_from_dbus(msg)
+                            }
+                            calloop::channel::Event::Closed => (),
+                        }
+                    })
+                    .unwrap();
+                let remote_desktop = RemoteDesktop {
+                    to_calloop: to_niri,
+                    #[cfg(feature = "xdp-gnome-screencast")]
+                    shared: remote_desktop_shared.clone(),
+                };
+                dbus.conn_remote_desktop = try_start(remote_desktop);
+            }
+
             #[cfg(feature = "xdp-gnome-screencast")]
             {
                 let (to_niri, from_screen_cast) = calloop::channel::channel();
@@ -127,7 +159,17 @@ impl DBusServers {
                         }
                     })
                     .unwrap();
-                let screen_cast = ScreenCast::new(backend.ipc_outputs(), to_niri);
+
+                let screen_cast = ScreenCast::new(
+                    backend.ipc_outputs(),
+                    to_niri,
+                    #[cfg(feature = "xdp-gnome-remote-desktop")]
+                    remote_desktop_shared,
+                    #[cfg(feature = "xdp-gnome-remote-desktop")]
+                    dbus.conn_remote_desktop
+                        .as_ref()
+                        .map(|conn| conn.object_server().inner().clone()),
+                );
                 dbus.conn_screen_cast = try_start(screen_cast);
             }
 
diff --git a/src/dbus/mutter_remote_desktop.rs b/src/dbus/mutter_remote_desktop.rs
new file mode 100644
index 00000000..129a19ff
--- /dev/null
+++ b/src/dbus/mutter_remote_desktop.rs
@@ -0,0 +1,740 @@
+//! `org.gnome.Mutter.RemoteDesktop` implementation. `xdg-desktop-portal-gnome` implements the
+//! Remote Desktop portal on top of this.
+
+use std::os::fd::OwnedFd;
+use std::os::unix::net::UnixStream;
+#[cfg(feature = "xdp-gnome-screencast")]
+use std::sync::Arc;
+
+use bitflags::bitflags;
+use enumflags2::BitFlags;
+#[cfg(feature = "xdp-gnome-screencast")]
+use futures_util::lock::Mutex;
+use serde::{Deserialize, Serialize};
+use smithay::backend::input::{AxisSource, KeyState, Keycode};
+use smithay::utils::{Logical, Point, Rectangle, Size};
+use zbus::fdo::{self, RequestNameFlags};
+#[cfg(feature = "xdp-gnome-screencast")]
+use zbus::object_server::InterfaceRef;
+use zbus::object_server::SignalEmitter;
+use zbus::zvariant::{self, DeserializeDict, OwnedObjectPath, SerializeDict, Type};
+use zbus::{interface, ObjectServer};
+
+use super::Start;
+use crate::backend::IpcOutputMap;
+use crate::input::remote_desktop_backend::{
+    RdAbsolutePosition, RdEventAdapter, RdInputBackend, RdKeyboardKeyEvent, RdPointerAxisEvent,
+    RdPointerButtonEvent, RdPointerMotionAbsoluteEvent, RdPointerMotionEvent, RdTouchEvent,
+    UnitIntervalPointKind,
+};
+use crate::utils::RemoteDesktopSessionId;
+
+#[cfg(feature = "xdp-gnome-screencast")]
+pub(super) mod shared {
+    use std::collections::HashMap;
+    use std::sync::Arc;
+
+    use futures_util::lock::Mutex;
+    use zbus::object_server::InterfaceRef;
+
+    use crate::utils::RemoteDesktopSessionId;
+
+    /// Data shared between `org.gnome.Mutter.ScreenCast` and `org.gnome.Mutter.RemoteDesktop`
+    #[derive(Default)]
+    pub struct RemoteDesktopShared {
+        pub(in super::super) sessions:
+            HashMap<RemoteDesktopSessionId, InterfaceRef<super::Session>>,
+    }
+    impl RemoteDesktopShared {
+        pub fn new_arc_mutex() -> Arc<Mutex<Self>> {
+            Arc::new(Mutex::new(Self::default()))
+        }
+    }
+}
+
+type InputEvent = smithay::backend::input::InputEvent<RdInputBackend>;
+
+pub enum RemoteDesktopDBusToCalloop {
+    RemoveEisHandler {
+        session_id: RemoteDesktopSessionId,
+    },
+    NewEisContext {
+        session_id: RemoteDesktopSessionId,
+        ctx: reis::eis::Context,
+        exposed_device_types: BitFlags<MutterXdpDeviceType>,
+    },
+    EmulateInput(InputEvent),
+    EmulateKeysym {
+        /// X11 keysym, like in the `xkeysym` crate
+        keysym: u32,
+        state: KeyState,
+        session_id: RemoteDesktopSessionId,
+        time: u64,
+    },
+    /// Increments the number of remote desktop sessions that need touch capability on the
+    /// seat.
+    IncTouchSession,
+    /// Decrements the number of remote desktop sessions that need touch capability on the
+    /// seat.
+    DecTouchSession,
+}
+
+// == MAIN INTERFACE ==
+
+/// D-Bus object for the remote desktop portal's implementation
+pub(super) struct RemoteDesktop {
+    pub(super) to_calloop: calloop::channel::Sender<RemoteDesktopDBusToCalloop>,
+    #[cfg(feature = "xdp-gnome-screencast")]
+    pub(super) shared: Arc<Mutex<shared::RemoteDesktopShared>>,
+}
+
+impl Start for RemoteDesktop {
+    fn start(self) -> anyhow::Result<zbus::blocking::Connection> {
+        let conn = zbus::blocking::Connection::session()?;
+        let flags = RequestNameFlags::AllowReplacement
+            | RequestNameFlags::ReplaceExisting
+            | RequestNameFlags::DoNotQueue;
+
+        conn.object_server()
+            .at("/org/gnome/Mutter/RemoteDesktop", self)?;
+        conn.request_name_with_flags("org.gnome.Mutter.RemoteDesktop", flags)?;
+
+        Ok(conn)
+    }
+}
+
+#[interface(
+    name = "org.gnome.Mutter.RemoteDesktop",
+    spawn = false,
+    introspection_docs = false
+)]
+impl RemoteDesktop {
+    async fn create_session(
+        &self,
+        #[zbus(object_server)] server: &ObjectServer,
+    ) -> fdo::Result<OwnedObjectPath> {
+        let session_id = RemoteDesktopSessionId::next();
+        let path = format!(
+            "/org/gnome/Mutter/RemoteDesktop/Session/u{}",
+            session_id.get()
+        );
+        let path = OwnedObjectPath::try_from(path).unwrap();
+
+        debug!("Created new RemoteDesktop.Session with ID {}", session_id);
+
+        let session = Session {
+            id: session_id,
+            id_str: session_id.to_string(),
+            to_calloop: self.to_calloop.clone(),
+            shared: self.shared.clone(),
+            active: false,
+            using_eis: false,
+            using_touch: false,
+            #[cfg(feature = "xdp-gnome-screencast")]
+            screen_cast_session: None,
+        };
+
+        match server.at(&path, session).await {
+            Ok(true) => {
+                #[cfg(feature = "xdp-gnome-screencast")]
+                {
+                    let iface = server.interface(&path).await.unwrap();
+                    self.shared.lock().await.sessions.insert(session_id, iface);
+                }
+            }
+            Ok(false) => return Err(fdo::Error::Failed("session path already exists".to_owned())),
+            Err(err) => {
+                return Err(fdo::Error::Failed(format!(
+                    "error creating session object: {err:?}"
+                )))
+            }
+        }
+
+        Ok(path)
+    }
+
+    /// Bitmask of supported device types
+    #[zbus(property)]
+    async fn supported_device_types(&self) -> u32 {
+        BitFlags::<MutterXdpDeviceType>::all().bits()
+    }
+
+    #[zbus(property)]
+    async fn version(&self) -> i32 {
+        1
+    }
+}
+
+// == SESSION ==
+
+/// D-Bus object for a remote desktop session
+pub(super) struct Session {
+    id: RemoteDesktopSessionId,
+    id_str: String,
+    to_calloop: calloop::channel::Sender<RemoteDesktopDBusToCalloop>,
+    shared: Arc<Mutex<shared::RemoteDesktopShared>>,
+    pub active: bool,
+    using_eis: bool,
+    /// Whether the main thread has been informed that this requires touch capability on the
+    /// seat.
+    using_touch: bool,
+    #[cfg(feature = "xdp-gnome-screencast")]
+    pub screen_cast_session: Option<(
+        InterfaceRef<super::mutter_screen_cast::Session>,
+        ObjectServer,
+    )>,
+}
+
+impl Session {
+    fn emulate_input(&mut self, event: InputEvent) {
+        if matches!(
+            event,
+            InputEvent::TouchDown { .. }
+                | InputEvent::TouchMotion { .. }
+                | InputEvent::TouchUp { .. }
+                | InputEvent::TouchCancel { .. }
+                | InputEvent::TouchFrame { .. }
+        ) && !self.using_touch
+        {
+            if let Err(err) = self
+                .to_calloop
+                .send(RemoteDesktopDBusToCalloop::IncTouchSession)
+            {
+                warn!("error sending IncTouchSession to calloop: {err:?}");
+            } else {
+                self.using_touch = true;
+            }
+        }
+
+        if let Err(err) = self
+            .to_calloop
+            .send(RemoteDesktopDBusToCalloop::EmulateInput(event))
+        {
+            warn!("error sending EmulateInput to calloop: {err:?}");
+        }
+    }
+    fn wrap_event<Ev>(&self, inner: Ev) -> RdEventAdapter<Ev> {
+        RdEventAdapter {
+            session_id: self.id,
+            time: Self::time_now(),
+            inner,
+        }
+    }
+    fn time_now() -> u64 {
+        // TODO: do we really need CLOCK_MONOTONIC?
+        0
+    }
+
+    /// Converts a logical pixel point in the stream corodinate space into a unit interval point in
+    /// the global bounding rectangle.
+    ///
+    /// - `stream_path`: D-Bus object path like `/org/gnome/Mutter/ScreenCast/Stream/u7`
+    async fn convert_stream_coordinate_space(
+        &self,
+        stream_path: &str,
+        x: f64,
+        y: f64,
+    ) -> fdo::Result<Point<f64, UnitIntervalPointKind>> {
+        fn global_bounding_rectangle(
+            ipc_outputs: &IpcOutputMap,
+        ) -> Option<Rectangle<i32, Logical>> {
+            ipc_outputs
+                .values()
+                .filter_map(|output| output.logical)
+                .fold(None, |acc, l| {
+                    let geo = Rectangle::new(
+                        Point::new(l.x, l.y),
+                        Size::new(l.width as i32, l.height as i32),
+                    );
+                    Some(acc.map_or(geo, |acc| acc.merge(geo)))
+                })
+        }
+
+        let in_point = Point::<f64, Logical>::new(x, y);
+
+        let Some((screen_cast_iface, screen_cast_object_server)) = &self.screen_cast_session else {
+            return Err(fdo::Error::Failed(
+                "Must have screencast session for absolute coordinates".to_owned(),
+            ));
+        };
+
+        let Ok(stream) = screen_cast_object_server
+            .interface::<_, super::mutter_screen_cast::Stream>(stream_path)
+            .await
+        else {
+            return Err(fdo::Error::Failed("Unknown stream".to_owned()));
+        };
+
+        // position of the stream in the global bounding rectangle
+        let stream_position = {
+            let params = stream.get().await.parameters();
+            Point::new(params.position.0, params.position.1)
+        };
+
+        let Some(output_geo) = ({
+            let screen_cast_state = screen_cast_iface.get().await;
+            let ipc_outputs = screen_cast_state.ipc_outputs.lock().unwrap();
+            global_bounding_rectangle(&ipc_outputs)
+        }) else {
+            return Err(fdo::Error::Failed(
+                "Missing outputs for getting global bounding rectangle".to_owned(),
+            ));
+        };
+
+        let out_point = (stream_position.to_f64() + in_point - output_geo.loc.to_f64()).to_size()
+            / output_geo.size.to_f64();
+        let out_point = Point::new(out_point.x, out_point.y);
+
+        Ok(out_point)
+    }
+
+    /// Stops the session.
+    pub async fn stop(&mut self, server: &ObjectServer, ctxt: &SignalEmitter<'_>) {
+        if !self.active {
+            return;
+        }
+        self.active = false;
+
+        #[cfg(feature = "xdp-gnome-screencast")]
+        {
+            // Remove reference to this interface so it can be dropped
+            self.shared.lock().await.sessions.remove(&self.id);
+
+            if let Some((iface, server)) = &self.screen_cast_session {
+                iface
+                    .get_mut()
+                    .await
+                    .stop_no_remote_desktop(server, iface.signal_emitter())
+                    .await;
+            }
+
+            // Remove reference to the screencast interface so it can be dropped
+            self.screen_cast_session = None;
+        }
+
+        Self::closed(ctxt).await.unwrap();
+
+        let obj_was_destroyed = server.remove::<Session, _>(ctxt.path()).await.unwrap();
+        trace!(
+            obj_was_destroyed,
+            "removed RemoteDesktop.Session id={} from server",
+            self.id
+        );
+    }
+}
+
+#[derive(Debug, DeserializeDict, Type)]
+#[zvariant(signature = "dict")]
+struct ClipboardOptions {
+    #[zvariant(rename = "mime-types")]
+    _mime_types: Option<Vec<String>>,
+}
+
+#[derive(Debug, SerializeDict, Type)]
+#[zvariant(signature = "dict")]
+struct SelectionOwnerChangedOptions {
+    #[zvariant(rename = "mime-types")]
+    mime_types: Option<Vec<String>>,
+    #[zvariant(rename = "session-is-owner")]
+    session_is_owner: Option<bool>,
+}
+
+#[derive(Debug, DeserializeDict, Type)]
+#[zvariant(signature = "dict")]
+struct ConnectToEisOptions {
+    /// Bitflags of device types to expose and filter in EIS.
+    ///
+    /// Must be in `SupportedDeviceTypes` and is based on user's choice via portal
+    #[zvariant(rename = "device-types")]
+    device_types: Option<BitFlags<MutterXdpDeviceType>>,
+}
+#[derive(Serialize, Deserialize, Debug, Type, PartialEq, Eq, Clone, Copy)]
+pub struct MutterXdpPointerAxisFlags(u32);
+
+bitflags! {
+    impl MutterXdpPointerAxisFlags: u32 {
+        /// Note: only this is currently provided by xdp-gnome
+        const FINISH = 1;
+        const SOURCE_WHEEL = 1 << 1;
+        const SOURCE_FINGER = 1 << 2;
+        const SOURCE_CONTINUOUS = 1 << 3;
+    }
+}
+
+#[derive(Serialize, Deserialize, Debug, Type, PartialEq, Eq, Clone, Copy)]
+#[enumflags2::bitflags]
+#[repr(u32)]
+pub enum MutterXdpDeviceType {
+    Keyboard = 1,
+    Pointer = 1 << 1,
+    Touchscreen = 1 << 2,
+}
+
+impl MutterXdpDeviceType {
+    /// To [`reis`] capabilities for exposing only portal-selected device capabilities
+    pub fn to_reis_capabilities(flags: BitFlags<Self>) -> BitFlags<reis::event::DeviceCapability> {
+        use reis::event::DeviceCapability;
+        let mut out_flags = BitFlags::empty();
+        for flag in flags {
+            match flag {
+                MutterXdpDeviceType::Keyboard => out_flags |= DeviceCapability::Keyboard,
+                MutterXdpDeviceType::Pointer => {
+                    out_flags |= DeviceCapability::Pointer
+                        | DeviceCapability::Scroll
+                        | DeviceCapability::Button
+                        | DeviceCapability::PointerAbsolute
+                }
+                MutterXdpDeviceType::Touchscreen => out_flags |= DeviceCapability::Touch,
+            }
+        }
+        out_flags
+    }
+}
+
+#[interface(
+    name = "org.gnome.Mutter.RemoteDesktop.Session",
+    spawn = false,
+    introspection_docs = false
+)]
+impl Session {
+    #[zbus(property)]
+    async fn session_id(&self) -> &str {
+        &self.id_str
+    }
+
+    async fn start(&mut self) -> fdo::Result<()> {
+        debug!("RemoteDesktop.Start id={}", self.id);
+
+        if self.active {
+            return Err(fdo::Error::Failed("Already started".to_owned()));
+        }
+        self.active = true;
+
+        #[cfg(feature = "xdp-gnome-screencast")]
+        if let Some((iface, _server)) = &self.screen_cast_session {
+            iface.get().await.start().await;
+            debug!("RemoteDesktop.Start started screencast");
+        }
+
+        // TODO: if (self.eis) initialize_viewports
+
+        // TODO: init_remote_access_handle
+
+        Ok(())
+    }
+
+    // TODO: stop when EIS disconnects
+    #[zbus(name = "Stop")]
+    pub async fn stop_dbus(
+        &mut self,
+        #[zbus(object_server)] server: &ObjectServer,
+        #[zbus(signal_context)] ctxt: SignalEmitter<'_>,
+    ) -> fdo::Result<()> {
+        debug!("RemoteDesktop.Stop id={}", self.id);
+
+        if !self.active {
+            return Err(fdo::Error::Failed("Session not started".to_owned()));
+        }
+
+        self.stop(server, &ctxt).await;
+
+        Ok(())
+    }
+
+    /// "A session doesn't have to have been started before it may be closed. After it being
+    /// closed, it can no longer be used."
+    #[zbus(signal)]
+    async fn closed(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;
+
+    //// Keyboard handlers
+
+    async fn notify_keyboard_keycode(
+        &mut self,
+        keycode: u32,
+        state_is_pressed: bool,
+    ) -> fdo::Result<()> {
+        self.emulate_input(InputEvent::Keyboard {
+            event: self.wrap_event(RdKeyboardKeyEvent {
+                // Offset from evdev keycodes (where KEY_ESCAPE is 1) to X11 keycodes
+                keycode: Keycode::new(keycode + 8),
+                state: if state_is_pressed {
+                    KeyState::Pressed
+                } else {
+                    KeyState::Released
+                },
+            }),
+        });
+        Ok(())
+    }
+
+    async fn notify_keyboard_keysym(
+        &mut self,
+        keysym: u32,
+        state_is_pressed: bool,
+    ) -> fdo::Result<()> {
+        if let Err(err) = self
+            .to_calloop
+            .send(RemoteDesktopDBusToCalloop::EmulateKeysym {
+                keysym,
+                state: if state_is_pressed {
+                    KeyState::Pressed
+                } else {
+                    KeyState::Released
+                },
+                session_id: self.id,
+                time: Self::time_now(),
+            })
+        {
+            warn!("error sending EmulateKeysym to calloop: {err:?}");
+        }
+        Ok(())
+    }
+
+    //// Pointer handlers
+
+    async fn notify_pointer_button(&mut self, button: i32, state: bool) -> fdo::Result<()> {
+        self.emulate_input(InputEvent::PointerButton {
+            event: self.wrap_event(RdPointerButtonEvent { button, state }),
+        });
+        Ok(())
+    }
+
+    async fn notify_pointer_axis(
+        &mut self,
+        mut dx: f64,
+        mut dy: f64,
+        flags: MutterXdpPointerAxisFlags,
+    ) -> fdo::Result<()> {
+        let finish = flags.contains(MutterXdpPointerAxisFlags::FINISH);
+
+        let source = if flags.contains(MutterXdpPointerAxisFlags::SOURCE_WHEEL) {
+            AxisSource::Wheel
+        } else if flags.contains(MutterXdpPointerAxisFlags::SOURCE_FINGER) {
+            AxisSource::Finger
+        } else if flags.contains(MutterXdpPointerAxisFlags::SOURCE_CONTINUOUS) {
+            AxisSource::Continuous
+        } else {
+            AxisSource::Wheel
+        };
+
+        if finish && source == AxisSource::Finger {
+            // Niri detects axis stop based on this
+            dx = 0.0;
+            dy = 0.0;
+        }
+
+        self.emulate_input(InputEvent::PointerAxis {
+            event: self.wrap_event(RdPointerAxisEvent {
+                source,
+                discrete: None,
+                delta: Some((dx, dy)),
+            }),
+        });
+
+        Ok(())
+    }
+
+    async fn notify_pointer_axis_discrete(&mut self, axis: u32, steps: i32) -> fdo::Result<()> {
+        debug!(axis, steps);
+        self.emulate_input(InputEvent::PointerAxis {
+            event: self.wrap_event(RdPointerAxisEvent {
+                source: AxisSource::Wheel,
+                delta: None,
+                discrete: Some(match axis {
+                    0 => (0, steps),
+                    _ => (steps, 0),
+                }),
+            }),
+        });
+
+        Ok(())
+    }
+
+    async fn notify_pointer_motion_relative(&mut self, dx: f64, dy: f64) -> fdo::Result<()> {
+        self.emulate_input(InputEvent::PointerMotion {
+            event: self.wrap_event(RdPointerMotionEvent { dx, dy }),
+        });
+        Ok(())
+    }
+
+    async fn notify_pointer_motion_absolute(
+        &mut self,
+        stream: &str,
+        x: f64,
+        y: f64,
+    ) -> fdo::Result<()> {
+        let pos = self.convert_stream_coordinate_space(stream, x, y).await?;
+
+        self.emulate_input(InputEvent::PointerMotionAbsolute {
+            event: self.wrap_event(RdPointerMotionAbsoluteEvent(RdAbsolutePosition { pos })),
+        });
+        Ok(())
+    }
+
+    //// Touch handlers
+
+    async fn notify_touch_down(
+        &mut self,
+        stream: &str,
+        slot: u32,
+        x: f64,
+        y: f64,
+    ) -> fdo::Result<()> {
+        let pos = self.convert_stream_coordinate_space(stream, x, y).await?;
+
+        self.emulate_input(InputEvent::TouchDown {
+            event: self.wrap_event(RdTouchEvent {
+                slot,
+                extra: RdAbsolutePosition { pos },
+            }),
+        });
+        Ok(())
+    }
+
+    async fn notify_touch_motion(
+        &mut self,
+        stream: &str,
+        slot: u32,
+        x: f64,
+        y: f64,
+    ) -> fdo::Result<()> {
+        let pos = self.convert_stream_coordinate_space(stream, x, y).await?;
+
+        self.emulate_input(InputEvent::TouchMotion {
+            event: self.wrap_event(RdTouchEvent {
+                slot,
+                extra: RdAbsolutePosition { pos },
+            }),
+        });
+        Ok(())
+    }
+
+    async fn notify_touch_up(&mut self, slot: u32) -> fdo::Result<()> {
+        self.emulate_input(InputEvent::TouchUp {
+            event: self.wrap_event(RdTouchEvent { slot, extra: () }),
+        });
+        Ok(())
+    }
+
+    //// Clipboard
+
+    /// Enables calling *Selection* and DisableClipboard
+    async fn enable_clipboard(&mut self, _options: ClipboardOptions) -> fdo::Result<()> {
+        // TODO!
+        Ok(())
+    }
+
+    async fn disable_clipbard(&mut self) -> fdo::Result<()> {
+        // TODO!
+        Ok(())
+    }
+
+    async fn set_selection(&mut self, _options: ClipboardOptions) -> fdo::Result<()> {
+        // TODO!
+        Ok(())
+    }
+
+    /// Answer to the [`selection_transfer`] signal
+    async fn selection_write(&mut self, _serial: u32) -> fdo::Result<zvariant::OwnedFd> {
+        // TODO!
+        todo!()
+    }
+
+    /// Notifies that the transfer of clipboard data through the file descriptor returned in
+    /// [`selection_write`] has either completed successfully, or failed
+    async fn selection_write_done(&mut self, _serial: u32, _successs: bool) -> fdo::Result<()> {
+        // TODO!
+        Ok(())
+    }
+
+    async fn selection_read(&mut self, _mime_type: &str) -> fdo::Result<zvariant::OwnedFd> {
+        // TODO!
+        todo!()
+    }
+
+    #[zbus(signal)]
+    async fn selection_owner_changed(
+        ctxt: &SignalEmitter<'_>,
+        options: SelectionOwnerChangedOptions,
+    ) -> zbus::Result<()>;
+
+    #[zbus(signal)]
+    async fn selection_transfer(
+        ctxt: &SignalEmitter<'_>,
+        mime_type: &str,
+        serial: u32,
+    ) -> zbus::Result<()>;
+
+    //// Properties
+
+    #[zbus(property)]
+    async fn caps_lock_state(&self) -> fdo::Result<bool> {
+        Err(fdo::Error::Failed("CapsLockState is deprecated and not used by xdg-desktop-portal-gnome. Because of that it's not implemented by Niri.".to_owned()))
+    }
+    #[zbus(property)]
+    async fn num_lock_state(&self) -> fdo::Result<bool> {
+        Err(fdo::Error::Failed("NumLockState is deprecated and not used by xdg-desktop-portal-gnome. Because of that it's not implemented by Niri.".to_owned()))
+    }
+
+    //// EIS
+
+    // TODO: make Notify* methods return errors once EIS is enabled (or is it done by xdp-gnome?)
+    // TODO: screencast mapping_id and libei device region
+    // TODO: Start and ConnectToEIS interactions?
+    #[zbus(name = "ConnectToEIS")]
+    async fn connect_to_eis(
+        &mut self,
+        options: ConnectToEisOptions,
+    ) -> fdo::Result<zvariant::OwnedFd> {
+        // TODO: xdp RemoteDesktop portal API specifies the below requirements, but what
+        // does xdp-gnome do?
+
+        // Mutter supports calling meta_eis_add_client_get_fd multiple times and also
+        // checks for EIS existence in the Start handler.
+
+        if !self.active {
+            return Err(fdo::Error::Failed("Session not started".to_owned()));
+        }
+        if self.using_eis {
+            return Err(fdo::Error::Failed("Already gave EIS socket".to_owned()));
+        }
+        self.using_eis = true;
+
+        let (a, b) = UnixStream::pair().map_err(zbus::Error::from)?;
+        let ctx = reis::eis::Context::new(a).map_err(zbus::Error::from)?;
+
+        debug!("RemoteDesktop.ConnectToEIS");
+
+        if let Err(err) = self
+            .to_calloop
+            .send(RemoteDesktopDBusToCalloop::NewEisContext {
+                session_id: self.id,
+                ctx,
+                exposed_device_types: options.device_types.unwrap_or_else(BitFlags::all),
+            })
+        {
+            warn!("error sending NewEisContext to calloop: {err:?}");
+        }
+
+        Ok(OwnedFd::from(b).into())
+    }
+}
+
+impl Drop for Session {
+    fn drop(&mut self) {
+        debug!("RemoteDesktop.Session id={} is being dropped", self.id);
+        if self.using_eis {
+            let _ = self
+                .to_calloop
+                .send(RemoteDesktopDBusToCalloop::RemoveEisHandler {
+                    session_id: self.id,
+                });
+        }
+
+        if self.using_touch {
+            let _ = self
+                .to_calloop
+                .send(RemoteDesktopDBusToCalloop::DecTouchSession);
+        }
+    }
+}
diff --git a/src/dbus/mutter_screen_cast.rs b/src/dbus/mutter_screen_cast.rs
index 82591bd3..9dc2a26f 100644
--- a/src/dbus/mutter_screen_cast.rs
+++ b/src/dbus/mutter_screen_cast.rs
@@ -1,8 +1,8 @@
-use std::collections::HashMap;
 use std::mem;
 use std::sync::atomic::{AtomicBool, Ordering};
-use std::sync::{Arc, Mutex};
+use std::sync::{Arc, Mutex as StdMutex};
 
+use futures_util::lock::Mutex;
 use serde::Deserialize;
 use zbus::fdo::RequestNameFlags;
 use zbus::object_server::{InterfaceRef, SignalEmitter};
@@ -11,121 +11,143 @@ use zbus::{fdo, interface, ObjectServer};
 
 use super::Start;
 use crate::backend::IpcOutputMap;
+#[cfg(feature = "xdp-gnome-remote-desktop")]
+use crate::dbus::mutter_remote_desktop::shared::RemoteDesktopShared;
 use crate::utils::{CastSessionId, CastStreamId};
 
-#[derive(Clone)]
-pub struct ScreenCast {
-    ipc_outputs: Arc<Mutex<IpcOutputMap>>,
-    to_niri: calloop::channel::Sender<ScreenCastToNiri>,
-    #[allow(clippy::type_complexity)]
-    sessions: Arc<Mutex<Vec<(Session, InterfaceRef<Session>)>>>,
-}
-
-#[derive(Clone)]
-pub struct Session {
-    id: CastSessionId,
-    ipc_outputs: Arc<Mutex<IpcOutputMap>>,
-    to_niri: calloop::channel::Sender<ScreenCastToNiri>,
-    #[allow(clippy::type_complexity)]
-    streams: Arc<Mutex<Vec<(Stream, InterfaceRef<Stream>)>>>,
-    stopped: Arc<AtomicBool>,
-}
-
-#[derive(Debug, Default, Deserialize, Type, Clone, Copy, PartialEq, Eq)]
-pub enum CursorMode {
-    #[default]
-    Hidden = 0,
-    Embedded = 1,
-    Metadata = 2,
-}
-
-#[derive(Debug, DeserializeDict, Type)]
-#[zvariant(signature = "dict")]
-struct RecordMonitorProperties {
-    #[zvariant(rename = "cursor-mode")]
-    cursor_mode: Option<CursorMode>,
-    #[zvariant(rename = "is-recording")]
-    _is_recording: Option<bool>,
-}
-
-#[derive(Debug, DeserializeDict, Type)]
-#[zvariant(signature = "dict")]
-struct RecordWindowProperties {
-    #[zvariant(rename = "window-id")]
-    window_id: u64,
-    #[zvariant(rename = "cursor-mode")]
-    cursor_mode: Option<CursorMode>,
-    #[zvariant(rename = "is-recording")]
-    _is_recording: Option<bool>,
-}
-
-#[derive(Clone)]
-pub struct Stream {
-    id: CastStreamId,
-    session_id: CastSessionId,
-    target: StreamTarget,
-    cursor_mode: CursorMode,
-    was_started: Arc<AtomicBool>,
-    to_niri: calloop::channel::Sender<ScreenCastToNiri>,
-}
-
-#[derive(Clone)]
-enum StreamTarget {
-    // FIXME: update on scale changes and whatnot.
-    Output(niri_ipc::Output),
-    Window { id: u64 },
-}
-
-#[derive(Debug, Clone)]
-pub enum StreamTargetId {
-    Output { name: String },
-    Window { id: u64 },
-}
-
-#[derive(Debug, SerializeDict, Type, Value)]
-#[zvariant(signature = "dict")]
-struct StreamParameters {
-    /// Position of the stream in logical coordinates.
-    position: (i32, i32),
-    /// Size of the stream in logical coordinates.
-    size: (i32, i32),
-}
-
 pub enum ScreenCastToNiri {
-    StartCast {
+    /// Starts a stream associated with a screencast session.
+    StartStream {
         session_id: CastSessionId,
         stream_id: CastStreamId,
         target: StreamTargetId,
         cursor_mode: CursorMode,
         signal_ctx: SignalEmitter<'static>,
     },
+    /// Stops all streams associated with the specified screencast session.
     StopCast {
         session_id: CastSessionId,
+        /// The reason for stopping the screencast, mainly for debugging.
+        reason: StopCastReason,
     },
 }
 
+#[derive(Debug)]
+pub enum StopCastReason {
+    RemoteDesktopStopped,
+    FromNiriStopCast,
+    DbusStop,
+    SessionDropped,
+}
+
+// == ROOT INTERFACE ==
+
+#[derive(Clone)]
+pub struct ScreenCast {
+    ipc_outputs: Arc<StdMutex<IpcOutputMap>>,
+    to_niri: calloop::channel::Sender<ScreenCastToNiri>,
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    remote_desktop_shared: Arc<Mutex<RemoteDesktopShared>>,
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    remote_desktop_object_server: Option<ObjectServer>,
+}
+
+#[derive(Debug, DeserializeDict, Type)]
+#[zvariant(signature = "dict")]
+struct CreateSessionProperties {
+    #[zvariant(rename = "remote-desktop-session-id")]
+    remote_desktop_session_id: Option<String>,
+}
+
 #[interface(name = "org.gnome.Mutter.ScreenCast")]
 impl ScreenCast {
     async fn create_session(
         &self,
         #[zbus(object_server)] server: &ObjectServer,
-        properties: HashMap<&str, Value<'_>>,
+        properties: CreateSessionProperties,
     ) -> fdo::Result<OwnedObjectPath> {
-        if properties.contains_key("remote-desktop-session-id") {
+        #[cfg(not(feature = "xdp-gnome-remote-desktop"))]
+        if properties.remote_desktop_session_id.is_some() {
             return Err(fdo::Error::Failed(
-                "there are no remote desktop sessions".to_owned(),
+                "Remote desktop support has been disabled at compile time in Niri".to_owned(),
             ));
         }
 
+        #[cfg(feature = "xdp-gnome-remote-desktop")]
+        let rd_session_iface = if let Some(rd_session_id) = properties.remote_desktop_session_id {
+            use crate::utils::RemoteDesktopSessionId;
+
+            debug!(rd_session_id, "ScreenCast.CreateSession");
+            let rd_session_id: u64 = rd_session_id.parse().map_err(|err| {
+                fdo::Error::Failed(format!("Invalid remote desktop session ID: {err}"))
+            })?;
+            let rd_session_id = RemoteDesktopSessionId::from(rd_session_id);
+
+            let shared = self.remote_desktop_shared.lock().await;
+
+            Some(
+                shared
+                    .sessions
+                    .get(&rd_session_id)
+                    .ok_or(fdo::Error::Failed(
+                        "No matching remote desktop session".to_owned(),
+                    ))?
+                    .clone(),
+            )
+        } else {
+            None
+        };
+
+        #[cfg(feature = "xdp-gnome-remote-desktop")]
+        let rd_session_state = if let Some(iface) = &rd_session_iface {
+            let state = iface.get_mut().await;
+
+            if state.active {
+                return Err(fdo::Error::Failed(
+                    "The remote desktop session has already started".to_owned(),
+                ));
+            }
+
+            if state.screen_cast_session.is_some() {
+                return Err(fdo::Error::Failed(
+                    "The remote desktop session already has an associated screencast session"
+                        .to_owned(),
+                ));
+            }
+
+            Some(state)
+        } else {
+            None
+        };
+
         let session_id = CastSessionId::next();
         let path = format!("/org/gnome/Mutter/ScreenCast/Session/u{}", session_id.get());
         let path = OwnedObjectPath::try_from(path).unwrap();
 
-        let session = Session::new(session_id, self.ipc_outputs.clone(), self.to_niri.clone());
-        match server.at(&path, session.clone()).await {
+        let session = Session {
+            id: session_id,
+            ipc_outputs: self.ipc_outputs.clone(),
+            streams: Arc::new(Mutex::new(vec![])),
+            to_niri: self.to_niri.clone(),
+            stopped: Arc::new(AtomicBool::new(false)),
+            sent_stop_cast: Arc::new(AtomicBool::new(false)),
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            rd_session: rd_session_iface.as_ref().and_then(|iface| {
+                Some((
+                    iface.clone(),
+                    self.remote_desktop_object_server.as_ref()?.clone(),
+                ))
+            }),
+        };
+
+        match server.at(&path, session).await {
             Ok(true) => {
                 let iface = server.interface(&path).await.unwrap();
-                self.sessions.lock().unwrap().push((session, iface));
+
+                #[cfg(feature = "xdp-gnome-remote-desktop")]
+                if let Some(mut state) = rd_session_state {
+                    state.screen_cast_session = Some((iface.clone(), server.clone()));
+                }
             }
             Ok(false) => return Err(fdo::Error::Failed("session path already exists".to_owned())),
             Err(err) => {
@@ -144,47 +166,126 @@ impl ScreenCast {
     }
 }
 
+impl ScreenCast {
+    pub fn new(
+        ipc_outputs: Arc<StdMutex<IpcOutputMap>>,
+        to_niri: calloop::channel::Sender<ScreenCastToNiri>,
+        #[cfg(feature = "xdp-gnome-remote-desktop")] remote_desktop_shared: Arc<
+            Mutex<RemoteDesktopShared>,
+        >,
+        #[cfg(feature = "xdp-gnome-remote-desktop")] remote_desktop_object_server: Option<
+            ObjectServer,
+        >,
+    ) -> Self {
+        Self {
+            ipc_outputs,
+            to_niri,
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            remote_desktop_shared,
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            remote_desktop_object_server,
+        }
+    }
+}
+
+impl Start for ScreenCast {
+    fn start(self) -> anyhow::Result<zbus::blocking::Connection> {
+        let conn = zbus::blocking::Connection::session()?;
+        let flags = RequestNameFlags::AllowReplacement
+            | RequestNameFlags::ReplaceExisting
+            | RequestNameFlags::DoNotQueue;
+
+        conn.object_server()
+            .at("/org/gnome/Mutter/ScreenCast", self)?;
+        conn.request_name_with_flags("org.gnome.Mutter.ScreenCast", flags)?;
+
+        Ok(conn)
+    }
+}
+
+// == SESSION ==
+
+pub struct Session {
+    id: CastSessionId,
+    pub ipc_outputs: Arc<StdMutex<IpcOutputMap>>,
+    to_niri: calloop::channel::Sender<ScreenCastToNiri>,
+    #[allow(clippy::type_complexity)]
+    streams: Arc<Mutex<Vec<InterfaceRef<Stream>>>>,
+    stopped: Arc<AtomicBool>,
+    sent_stop_cast: Arc<AtomicBool>,
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    rd_session: Option<(
+        InterfaceRef<super::mutter_remote_desktop::Session>,
+        ObjectServer,
+    )>,
+}
+
+#[derive(Debug, Default, Deserialize, Type, Clone, Copy, PartialEq, Eq)]
+pub enum CursorMode {
+    #[default]
+    Hidden = 0,
+    Embedded = 1,
+    Metadata = 2,
+}
+
+#[derive(Debug, DeserializeDict, Type)]
+#[zvariant(signature = "dict")]
+struct RecordMonitorProperties {
+    #[zvariant(rename = "cursor-mode")]
+    cursor_mode: Option<CursorMode>,
+    #[zvariant(rename = "is-recording")]
+    _is_recording: Option<bool>,
+}
+
+#[derive(Debug, DeserializeDict, Type)]
+#[zvariant(signature = "dict")]
+struct RecordWindowProperties {
+    #[zvariant(rename = "window-id")]
+    window_id: u64,
+    #[zvariant(rename = "cursor-mode")]
+    cursor_mode: Option<CursorMode>,
+    #[zvariant(rename = "is-recording")]
+    _is_recording: Option<bool>,
+}
+
 #[interface(name = "org.gnome.Mutter.ScreenCast.Session")]
 impl Session {
-    async fn start(&self) {
+    /// Starts the streams of this screencast session.
+    #[zbus(name = "Start")]
+    async fn start_dbus(&self) -> fdo::Result<()> {
         debug!("start");
 
-        for (stream, iface) in &*self.streams.lock().unwrap() {
-            stream.start(iface.signal_emitter().clone());
+        #[cfg(feature = "xdp-gnome-remote-desktop")]
+        if self.rd_session.is_some() {
+            return Err(fdo::Error::Failed(
+                "This session must be started from the linked remote desktop session".to_owned(),
+            ));
         }
+
+        self.start().await;
+        Ok(())
     }
 
-    pub async fn stop(
-        &self,
+    #[zbus(name = "Stop")]
+    async fn stop_dbus(
+        &mut self,
         #[zbus(object_server)] server: &ObjectServer,
         #[zbus(signal_context)] ctxt: SignalEmitter<'_>,
-    ) {
+    ) -> fdo::Result<()> {
         debug!("stop");
 
-        if self.stopped.swap(true, Ordering::SeqCst) {
-            // Already stopped.
-            return;
-        }
-
-        Session::closed(&ctxt).await.unwrap();
-
-        if let Err(err) = self.to_niri.send(ScreenCastToNiri::StopCast {
-            session_id: self.id,
-        }) {
-            warn!("error sending StopCast to niri: {err:?}");
-        }
-
-        let streams = mem::take(&mut *self.streams.lock().unwrap());
-        for (_, iface) in streams.iter() {
-            server
-                .remove::<Stream, _>(iface.signal_emitter().path())
-                .await
-                .unwrap();
+        #[cfg(feature = "xdp-gnome-remote-desktop")]
+        if self.rd_session.is_some() {
+            return Err(fdo::Error::Failed(
+                "This session must be stopped from the linked remote desktop session".to_owned(),
+            ));
         }
 
-        server.remove::<Session, _>(ctxt.path()).await.unwrap();
+        self.stop(server, &ctxt, StopCastReason::DbusStop).await;
+        Ok(())
     }
 
+    /// Creates a [`Stream`] that records a monitor.
     async fn record_monitor(
         &mut self,
         #[zbus(object_server)] server: &ObjectServer,
@@ -205,36 +306,13 @@ impl Session {
             return Err(fdo::Error::Failed("monitor is disabled".to_owned()));
         }
 
-        let stream_id = CastStreamId::next();
-        let path = format!("/org/gnome/Mutter/ScreenCast/Stream/u{}", stream_id.get());
-        let path = OwnedObjectPath::try_from(path).unwrap();
-
-        let cursor_mode = properties.cursor_mode.unwrap_or_default();
-
         let target = StreamTarget::Output(output);
-        let stream = Stream::new(
-            stream_id,
-            self.id,
-            target,
-            cursor_mode,
-            self.to_niri.clone(),
-        );
-        match server.at(&path, stream.clone()).await {
-            Ok(true) => {
-                let iface = server.interface(&path).await.unwrap();
-                self.streams.lock().unwrap().push((stream, iface));
-            }
-            Ok(false) => return Err(fdo::Error::Failed("stream path already exists".to_owned())),
-            Err(err) => {
-                return Err(fdo::Error::Failed(format!(
-                    "error creating stream object: {err:?}"
-                )))
-            }
-        }
+        let cursor_mode = properties.cursor_mode.unwrap_or_default();
 
-        Ok(path)
+        self.record_shared(target, cursor_mode, server).await
     }
 
+    /// Creates a [`Stream`] that records a window.
     async fn record_window(
         &mut self,
         #[zbus(object_server)] server: &ObjectServer,
@@ -242,26 +320,123 @@ impl Session {
     ) -> fdo::Result<OwnedObjectPath> {
         debug!(?properties, "record_window");
 
+        let target = StreamTarget::Window {
+            id: properties.window_id,
+        };
+        let cursor_mode = properties.cursor_mode.unwrap_or_default();
+
+        self.record_shared(target, cursor_mode, server).await
+    }
+
+    /// Event that the session has closed.
+    #[zbus(signal)]
+    async fn closed(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;
+}
+
+impl Session {
+    pub async fn start(&self) {
+        for iface in &*self.streams.lock().await {
+            iface.get().await.start(iface.signal_emitter().clone());
+        }
+    }
+
+    /// Stops the session.
+    async fn stop(
+        &mut self,
+        server: &ObjectServer,
+        ctxt: &SignalEmitter<'_>,
+        reason: StopCastReason,
+    ) {
+        if self.stop_inner(server, ctxt, reason).await {
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            if let Some((iface, server)) = &self.rd_session {
+                iface
+                    .get_mut()
+                    .await
+                    .stop(server, iface.signal_emitter())
+                    .await;
+            }
+        }
+    }
+    pub async fn stop_from_stopcast(&mut self, server: &ObjectServer, ctxt: &SignalEmitter<'_>) {
+        self.stop(server, ctxt, StopCastReason::FromNiriStopCast)
+            .await
+    }
+
+    /// Stops the session without trying to stop any associated remote desktop session.
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    pub(super) async fn stop_no_remote_desktop(
+        &mut self,
+        server: &ObjectServer,
+        ctxt: &SignalEmitter<'_>,
+    ) {
+        self.stop_inner(server, ctxt, StopCastReason::RemoteDesktopStopped)
+            .await;
+    }
+
+    async fn stop_inner(
+        &mut self,
+        server: &ObjectServer,
+        ctxt: &SignalEmitter<'_>,
+        reason: StopCastReason,
+    ) -> bool {
+        if self.stopped.swap(true, Ordering::SeqCst) {
+            // Already stopped.
+            return false;
+        }
+
+        // Remove reference to the remote desktop interface so it can be dropped
+        self.rd_session = None;
+
+        Session::closed(ctxt).await.unwrap();
+
+        if !self.sent_stop_cast.swap(true, Ordering::SeqCst) {
+            if let Err(err) = self.to_niri.send(ScreenCastToNiri::StopCast {
+                session_id: self.id,
+                reason,
+            }) {
+                warn!("error sending StopCast to niri: {err:?}");
+            }
+        }
+
+        let streams = mem::take(&mut *self.streams.lock().await);
+        for iface in streams.iter() {
+            server
+                .remove::<Stream, _>(iface.signal_emitter().path())
+                .await
+                .unwrap();
+        }
+
+        server.remove::<Session, _>(ctxt.path()).await.unwrap();
+
+        true
+    }
+
+    async fn record_shared(
+        &mut self,
+        target: StreamTarget,
+        cursor_mode: CursorMode,
+        server: &ObjectServer,
+    ) -> fdo::Result<OwnedObjectPath> {
         let stream_id = CastStreamId::next();
         let path = format!("/org/gnome/Mutter/ScreenCast/Stream/u{}", stream_id.get());
         let path = OwnedObjectPath::try_from(path).unwrap();
 
-        let cursor_mode = properties.cursor_mode.unwrap_or_default();
-
-        let target = StreamTarget::Window {
-            id: properties.window_id,
-        };
-        let stream = Stream::new(
-            stream_id,
-            self.id,
+        let stream = Stream {
+            id: stream_id,
+            session_id: self.id,
             target,
             cursor_mode,
-            self.to_niri.clone(),
-        );
-        match server.at(&path, stream.clone()).await {
+            was_started: Arc::new(AtomicBool::new(false)),
+            to_niri: self.to_niri.clone(),
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            has_remote_desktop_session: self.rd_session.is_some(),
+        };
+
+        match server.at(&path, stream).await {
             Ok(true) => {
                 let iface = server.interface(&path).await.unwrap();
-                self.streams.lock().unwrap().push((stream, iface));
+                self.streams.lock().await.push(iface);
             }
             Ok(false) => return Err(fdo::Error::Failed("stream path already exists".to_owned())),
             Err(err) => {
@@ -273,9 +448,69 @@ impl Session {
 
         Ok(path)
     }
+}
 
-    #[zbus(signal)]
-    async fn closed(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;
+impl Drop for Session {
+    fn drop(&mut self) {
+        if !self.sent_stop_cast.swap(true, Ordering::SeqCst) {
+            let _ = self.to_niri.send(ScreenCastToNiri::StopCast {
+                session_id: self.id,
+                reason: StopCastReason::SessionDropped,
+            });
+        }
+    }
+}
+
+// == STREAM ==
+
+pub struct Stream {
+    id: CastStreamId,
+    session_id: CastSessionId,
+    target: StreamTarget,
+    cursor_mode: CursorMode,
+    was_started: Arc<AtomicBool>,
+    to_niri: calloop::channel::Sender<ScreenCastToNiri>,
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    has_remote_desktop_session: bool,
+}
+
+#[derive(Clone)]
+enum StreamTarget {
+    // FIXME: update on scale changes and whatnot.
+    Output(niri_ipc::Output),
+    Window { id: u64 },
+}
+
+impl StreamTarget {
+    fn make_id(&self) -> StreamTargetId {
+        match self {
+            StreamTarget::Output(output) => StreamTargetId::Output {
+                name: output.name.clone(),
+            },
+            StreamTarget::Window { id } => StreamTargetId::Window { id: *id },
+        }
+    }
+}
+
+#[derive(Debug, Clone)]
+pub enum StreamTargetId {
+    Output { name: String },
+    Window { id: u64 },
+}
+
+#[derive(Debug, SerializeDict, Type, Value)]
+#[zvariant(signature = "dict")]
+pub struct StreamParameters {
+    /// Position of the stream in logical coordinates.
+    pub position: (i32, i32),
+    /// Size of the stream in logical coordinates.
+    pub size: (i32, i32),
+    /// Unique identifier used to map the stream to a corresponding region on an EI
+    /// absolute device (remote desktop).
+    ///
+    /// Currently output names (like eDP-1) are used.
+    #[zvariant(rename = "mapping-id")]
+    pub mapping_id: Option<String>,
 }
 
 #[interface(name = "org.gnome.Mutter.ScreenCast.Stream")]
@@ -285,13 +520,17 @@ impl Stream {
         -> zbus::Result<()>;
 
     #[zbus(property)]
-    async fn parameters(&self) -> StreamParameters {
+    pub(crate) fn parameters(&self) -> StreamParameters {
         match &self.target {
             StreamTarget::Output(output) => {
                 let logical = output.logical.as_ref().unwrap();
                 StreamParameters {
                     position: (logical.x, logical.y),
                     size: (logical.width as i32, logical.height as i32),
+                    #[cfg(feature = "xdp-gnome-remote-desktop")]
+                    mapping_id: self.has_remote_desktop_session.then(|| output.name.clone()),
+                    #[cfg(not(feature = "xdp-gnome-remote-desktop"))]
+                    mapping_id: None,
                 }
             }
             StreamTarget::Window { .. } => {
@@ -299,88 +538,23 @@ impl Stream {
                 StreamParameters {
                     position: (0, 0),
                     size: (1, 1),
+                    mapping_id: None, /* TODO: can you remotedesktop to
+                                       * a specific window??? */
                 }
             }
         }
     }
 }
 
-impl ScreenCast {
-    pub fn new(
-        ipc_outputs: Arc<Mutex<IpcOutputMap>>,
-        to_niri: calloop::channel::Sender<ScreenCastToNiri>,
-    ) -> Self {
-        Self {
-            ipc_outputs,
-            to_niri,
-            sessions: Arc::new(Mutex::new(vec![])),
-        }
-    }
-}
-
-impl Start for ScreenCast {
-    fn start(self) -> anyhow::Result<zbus::blocking::Connection> {
-        let conn = zbus::blocking::Connection::session()?;
-        let flags = RequestNameFlags::AllowReplacement
-            | RequestNameFlags::ReplaceExisting
-            | RequestNameFlags::DoNotQueue;
-
-        conn.object_server()
-            .at("/org/gnome/Mutter/ScreenCast", self)?;
-        conn.request_name_with_flags("org.gnome.Mutter.ScreenCast", flags)?;
-
-        Ok(conn)
-    }
-}
-
-impl Session {
-    pub fn new(
-        id: CastSessionId,
-        ipc_outputs: Arc<Mutex<IpcOutputMap>>,
-        to_niri: calloop::channel::Sender<ScreenCastToNiri>,
-    ) -> Self {
-        Self {
-            id,
-            ipc_outputs,
-            streams: Arc::new(Mutex::new(vec![])),
-            to_niri,
-            stopped: Arc::new(AtomicBool::new(false)),
-        }
-    }
-}
-
-impl Drop for Session {
-    fn drop(&mut self) {
-        let _ = self.to_niri.send(ScreenCastToNiri::StopCast {
-            session_id: self.id,
-        });
-    }
-}
-
 impl Stream {
-    fn new(
-        id: CastStreamId,
-        session_id: CastSessionId,
-        target: StreamTarget,
-        cursor_mode: CursorMode,
-        to_niri: calloop::channel::Sender<ScreenCastToNiri>,
-    ) -> Self {
-        Self {
-            id,
-            session_id,
-            target,
-            cursor_mode,
-            was_started: Arc::new(AtomicBool::new(false)),
-            to_niri,
-        }
-    }
-
+    /// Starts this stream.
     fn start(&self, ctxt: SignalEmitter<'static>) {
+        // TODO: remove was_started?
         if self.was_started.load(Ordering::SeqCst) {
             return;
         }
 
-        let msg = ScreenCastToNiri::StartCast {
+        let msg = ScreenCastToNiri::StartStream {
             session_id: self.session_id,
             stream_id: self.id,
             target: self.target.make_id(),
@@ -389,18 +563,7 @@ impl Stream {
         };
 
         if let Err(err) = self.to_niri.send(msg) {
-            warn!("error sending StartCast to niri: {err:?}");
-        }
-    }
-}
-
-impl StreamTarget {
-    fn make_id(&self) -> StreamTargetId {
-        match self {
-            StreamTarget::Output(output) => StreamTargetId::Output {
-                name: output.name.clone(),
-            },
-            StreamTarget::Window { id } => StreamTargetId::Window { id: *id },
+            warn!("error sending StartStream to niri: {err:?}");
         }
     }
 }
diff --git a/src/dbus/mutter_service_channel.rs b/src/dbus/mutter_service_channel.rs
index e226acb1..0c8adf44 100644
--- a/src/dbus/mutter_service_channel.rs
+++ b/src/dbus/mutter_service_channel.rs
@@ -45,6 +45,7 @@ impl ServiceChannel {
 
 impl Start for ServiceChannel {
     fn start(self) -> anyhow::Result<zbus::blocking::Connection> {
+        // TODO: flags= AllowReplacement, ReplaceExisting, DoNotQueue
         let conn = zbus::blocking::connection::Builder::session()?
             .name("org.gnome.Mutter.ServiceChannel")?
             .serve_at("/org/gnome/Mutter/ServiceChannel", self)?
diff --git a/src/input/eis_backend.rs b/src/input/eis_backend.rs
new file mode 100644
index 00000000..82801911
--- /dev/null
+++ b/src/input/eis_backend.rs
@@ -0,0 +1,341 @@
+//! Input backend for emulated input events received via [EI](https://libinput.pages.freedesktop.org/libei/).
+
+use reis::Interface;
+use smithay::backend::input::{
+    AbsolutePositionEvent, Axis, AxisRelativeDirection, AxisSource, ButtonState, Device,
+    DeviceCapability, Event, InputBackend, KeyState, KeyboardKeyEvent, Keycode, PointerAxisEvent,
+    PointerButtonEvent, PointerMotionAbsoluteEvent, PointerMotionEvent, TouchCancelEvent,
+    TouchDownEvent, TouchEvent, TouchFrameEvent, TouchMotionEvent, TouchSlot, TouchUpEvent,
+    UnusedEvent,
+};
+use smithay::output::Output;
+use smithay::utils::{Logical, Size};
+
+use crate::input::backend_ext::NiriInputDevice;
+use crate::niri::State;
+use crate::utils::RemoteDesktopSessionId;
+
+pub struct EisInputBackend;
+
+#[derive(Clone, Debug, Hash, Eq, PartialEq)]
+pub struct EisVirtualDevice {
+    /// Remote desktop session ID
+    pub session_id: RemoteDesktopSessionId,
+    /// Device ID unique to the remote desktop session
+    pub device_id: u64,
+}
+
+impl InputBackend for EisInputBackend {
+    type Device = EisVirtualDevice;
+
+    type KeyboardKeyEvent = EisEventAdapter<reis::request::KeyboardKey, PressedCount>;
+
+    type PointerAxisEvent = EisEventAdapter<reis::request::Frame, ScrollFrame>;
+    type PointerButtonEvent = EisEventAdapter<reis::request::Button>;
+    type PointerMotionEvent = EisEventAdapter<reis::request::PointerMotion>;
+    type PointerMotionAbsoluteEvent =
+        EisEventAdapter<reis::request::PointerMotionAbsolute, AbsolutePositionEventExtra>;
+
+    type GestureSwipeBeginEvent = UnusedEvent;
+    type GestureSwipeUpdateEvent = UnusedEvent;
+    type GestureSwipeEndEvent = UnusedEvent;
+    type GesturePinchBeginEvent = UnusedEvent;
+    type GesturePinchUpdateEvent = UnusedEvent;
+    type GesturePinchEndEvent = UnusedEvent;
+    type GestureHoldBeginEvent = UnusedEvent;
+    type GestureHoldEndEvent = UnusedEvent;
+
+    type TouchDownEvent = EisEventAdapter<reis::request::TouchDown, AbsolutePositionEventExtra>;
+    type TouchMotionEvent = EisEventAdapter<reis::request::TouchMotion, AbsolutePositionEventExtra>;
+    type TouchUpEvent = EisEventAdapter<reis::request::TouchUp>;
+    type TouchCancelEvent = EisEventAdapter<reis::request::TouchCancel>;
+    type TouchFrameEvent = EisEventAdapter<reis::request::Frame, TouchFrame>;
+
+    type TabletToolAxisEvent = UnusedEvent;
+    type TabletToolProximityEvent = UnusedEvent;
+    type TabletToolTipEvent = UnusedEvent;
+    type TabletToolButtonEvent = UnusedEvent;
+
+    type SwitchToggleEvent = UnusedEvent;
+
+    type SpecialEvent = UnusedEvent;
+}
+
+impl Device for EisVirtualDevice {
+    fn id(&self) -> String {
+        format!(
+            "Remote desktop (EIS) virtual device {}/{}",
+            self.session_id, self.device_id
+        )
+    }
+
+    fn name(&self) -> String {
+        String::from("Remote desktop (EIS) virtual device")
+    }
+
+    fn has_capability(&self, capability: DeviceCapability) -> bool {
+        // TODO: only actual EIS selected capabilities?
+        matches!(
+            capability,
+            DeviceCapability::Keyboard | DeviceCapability::Pointer | DeviceCapability::Touch
+        )
+    }
+
+    fn usb_id(&self) -> Option<(u32, u32)> {
+        None
+    }
+
+    fn syspath(&self) -> Option<std::path::PathBuf> {
+        None
+    }
+}
+
+impl NiriInputDevice for EisVirtualDevice {
+    fn output(&self, _state: &State) -> Option<Output> {
+        // This would map local output coordinates to global output
+        // coordinates if devices were per-output.
+        None
+    }
+}
+
+/// Wrapper to implement [`Event`] automatically and to hold extra data
+pub struct EisEventAdapter<Ev, Extra = ()> {
+    /// Remote desktop session ID
+    pub session_id: RemoteDesktopSessionId,
+    pub inner: Ev,
+    pub extra: Extra,
+}
+
+impl<Ev: reis::request::EventTime, Extra> Event<EisInputBackend> for EisEventAdapter<Ev, Extra> {
+    fn time(&self) -> u64 {
+        self.inner.time()
+    }
+
+    fn device(&self) -> <EisInputBackend as InputBackend>::Device {
+        EisVirtualDevice {
+            session_id: self.session_id,
+            device_id: self.inner.device().device().as_object().id(),
+        }
+    }
+}
+
+//-----------------//
+// KEYBOARD EVENTS //
+//-----------------//
+
+/// Extra passed to the keyboard key event containing the number of keys pressed on all devices in
+/// the seat.
+pub struct PressedCount(pub u32);
+
+impl KeyboardKeyEvent<EisInputBackend>
+    for EisEventAdapter<reis::request::KeyboardKey, PressedCount>
+{
+    fn key_code(&self) -> Keycode {
+        // Offset from evdev keycodes (where KEY_ESCAPE is 1) to X11 keycodes
+        Keycode::new(self.inner.key + 8)
+    }
+
+    fn state(&self) -> KeyState {
+        match self.inner.state {
+            reis::ei::keyboard::KeyState::Released => KeyState::Released,
+            reis::ei::keyboard::KeyState::Press => KeyState::Pressed,
+        }
+    }
+
+    fn count(&self) -> u32 {
+        // Smithay does this already...
+        self.extra.0
+    }
+}
+
+//----------------//
+// POINTER EVENTS //
+//----------------//
+
+#[derive(Default)]
+pub struct ScrollFrame {
+    /// Continuous scrolling, like on a touchpad.
+    pub delta: Option<(f32, f32)>,
+    /// 120-notch scrolling, like on a traditional mouse wheel.
+    ///
+    /// According to the EI protocol, 120 in discrete is the same as 1.0 in delta.
+    pub discrete: Option<(i32, i32)>,
+    /// Last bool denotes `is_cancel`
+    pub stop: Option<((bool, bool), bool)>,
+}
+
+fn tuple_axis<T>(tuple: (T, T), axis: Axis) -> T {
+    match axis {
+        Axis::Horizontal => tuple.0,
+        Axis::Vertical => tuple.1,
+    }
+}
+
+impl PointerAxisEvent<EisInputBackend> for EisEventAdapter<reis::request::Frame, ScrollFrame> {
+    // TODO: test on both continuous and wheel
+
+    // FIXME: contradiction:
+    // - `fn amount` documentation says that this is in pixels
+    // - EI protocol says that a single scroll notch is 1.0
+    // - Niri converts v120 to delta with (x/120*15)
+    fn amount(&self, axis: Axis) -> Option<f64> {
+        let mut value = tuple_axis(self.extra.delta?, axis) as f64;
+
+        if let Some(stop) = self.extra.stop {
+            if tuple_axis(stop.0, axis) {
+                // Niri detects axis stop based on this
+                value = 0.0;
+            }
+        }
+
+        Some(value)
+    }
+
+    fn amount_v120(&self, axis: Axis) -> Option<f64> {
+        // TODO: divide by 120?
+        Some(tuple_axis(self.extra.discrete?, axis) as f64)
+    }
+
+    fn source(&self) -> AxisSource {
+        // No source for this, can only guess
+        if self.extra.delta.is_some() || self.extra.stop.is_some() {
+            AxisSource::Continuous
+        } else {
+            AxisSource::Wheel
+        }
+    }
+
+    fn relative_direction(&self, _axis: Axis) -> AxisRelativeDirection {
+        AxisRelativeDirection::Identical
+    }
+}
+
+impl PointerButtonEvent<EisInputBackend> for EisEventAdapter<reis::request::Button> {
+    fn button_code(&self) -> u32 {
+        self.inner.button
+    }
+
+    fn state(&self) -> ButtonState {
+        match self.inner.state {
+            reis::ei::button::ButtonState::Released => ButtonState::Released,
+            reis::ei::button::ButtonState::Press => ButtonState::Pressed,
+        }
+    }
+}
+
+impl PointerMotionEvent<EisInputBackend> for EisEventAdapter<reis::request::PointerMotion> {
+    fn delta_x(&self) -> f64 {
+        self.inner.dx as f64
+    }
+
+    fn delta_y(&self) -> f64 {
+        self.inner.dy as f64
+    }
+
+    // Virtual pointer impl does this
+    fn delta_x_unaccel(&self) -> f64 {
+        self.inner.dx as f64
+    }
+
+    fn delta_y_unaccel(&self) -> f64 {
+        self.inner.dy as f64
+    }
+}
+
+pub struct AbsolutePositionEventExtra {
+    /// Extent of the global bounding rectangle (i.e. bounds of the raw X and Y coordinates)
+    pub global_extent: Size<f64, Logical>,
+}
+
+impl AbsolutePositionEvent<EisInputBackend>
+    for EisEventAdapter<reis::request::PointerMotionAbsolute, AbsolutePositionEventExtra>
+{
+    // Basically unused
+    fn x(&self) -> f64 {
+        (self.inner.dx_absolute as f64) / self.extra.global_extent.w
+    }
+
+    fn y(&self) -> f64 {
+        (self.inner.dy_absolute as f64) / self.extra.global_extent.h
+    }
+
+    // Position in global bounding rectangle
+    fn x_transformed(&self, width: i32) -> f64 {
+        (self.inner.dx_absolute as f64) / self.extra.global_extent.w * width as f64
+    }
+
+    fn y_transformed(&self, height: i32) -> f64 {
+        (self.inner.dy_absolute as f64) / self.extra.global_extent.h * height as f64
+    }
+}
+
+impl PointerMotionAbsoluteEvent<EisInputBackend>
+    for EisEventAdapter<reis::request::PointerMotionAbsolute, AbsolutePositionEventExtra>
+{
+}
+
+//--------------//
+// TOUCH EVENTS //
+//--------------//
+
+macro_rules! impl_touch_event {
+    ($($item_name:path),+$(,)?) => {
+        $(
+        impl<Extra> TouchEvent<EisInputBackend> for EisEventAdapter<$item_name, Extra> {
+            fn slot(&self) -> TouchSlot {
+                Some(self.inner.touch_id).into()
+            }
+        }
+        )+
+    }
+}
+
+impl_touch_event!(
+    reis::request::TouchDown,
+    reis::request::TouchMotion,
+    reis::request::TouchUp,
+    reis::request::TouchCancel,
+);
+
+macro_rules! impl_touch_abspos {
+    ($($item_name:path),+$(,)?) => {
+        $(
+        impl AbsolutePositionEvent<EisInputBackend> for EisEventAdapter<$item_name, AbsolutePositionEventExtra> {
+            // Basically unused
+            fn x(&self) -> f64 {
+                (self.inner.x as f64) / self.extra.global_extent.w
+            }
+
+            fn y(&self) -> f64 {
+                (self.inner.y as f64) / self.extra.global_extent.h
+            }
+
+            // Position in global bounding rectangle
+            fn x_transformed(&self, width: i32) -> f64 {
+                (self.inner.x as f64) / self.extra.global_extent.w * width as f64
+            }
+
+            fn y_transformed(&self, height: i32) -> f64 {
+                (self.inner.y as f64) / self.extra.global_extent.h * height as f64
+            }
+        }
+        )+
+    }
+}
+
+impl_touch_abspos!(reis::request::TouchDown, reis::request::TouchMotion);
+
+impl TouchDownEvent<EisInputBackend>
+    for EisEventAdapter<reis::request::TouchDown, AbsolutePositionEventExtra>
+{
+}
+impl TouchMotionEvent<EisInputBackend>
+    for EisEventAdapter<reis::request::TouchMotion, AbsolutePositionEventExtra>
+{
+}
+impl TouchUpEvent<EisInputBackend> for EisEventAdapter<reis::request::TouchUp> {}
+impl TouchCancelEvent<EisInputBackend> for EisEventAdapter<reis::request::TouchCancel> {}
+
+pub struct TouchFrame;
+
+impl TouchFrameEvent<EisInputBackend> for EisEventAdapter<reis::request::Frame, TouchFrame> {}
diff --git a/src/input/mod.rs b/src/input/mod.rs
index ab31df94..6229ca4e 100644
--- a/src/input/mod.rs
+++ b/src/input/mod.rs
@@ -55,9 +55,13 @@ use crate::utils::spawning::{spawn, spawn_sh};
 use crate::utils::{center, get_monotonic_time, CastSessionId, ResizeEdge};
 
 pub mod backend_ext;
+#[cfg(feature = "reis")]
+pub mod eis_backend;
 pub mod move_grab;
 pub mod pick_color_grab;
 pub mod pick_window_grab;
+#[cfg(feature = "xdp-gnome-remote-desktop")]
+pub mod remote_desktop_backend;
 pub mod resize_grab;
 pub mod scroll_swipe_gesture;
 pub mod scroll_tracker;
@@ -112,6 +116,7 @@ impl<D: SeatHandler> PointerOrTouchStartData<D> {
 }
 
 impl State {
+    /// Handler for all input events.
     pub fn process_input_event<I: InputBackend + 'static>(&mut self, event: InputEvent<I>)
     where
         I::Device: 'static, // Needed for downcasting.
@@ -194,6 +199,8 @@ impl State {
         }
     }
 
+    /// Special handler for events that come from libinput. After this it should be processed
+    /// by [`Self::process_input_event`].
     pub fn process_libinput_event(&mut self, event: &mut InputEvent<LibinputInputBackend>) {
         let _span = tracy_client::span!("process_libinput_event");
 
@@ -247,9 +254,8 @@ impl State {
             let desc = TabletDescriptor::from(&device);
             tablet_seat.add_tablet::<Self>(&self.niri.display_handle, &desc);
         }
-        if device.has_capability(DeviceCapability::Touch) && self.niri.seat.get_touch().is_none() {
-            self.niri.seat.add_touch();
-        }
+
+        self.refresh_wayland_device_caps();
     }
 
     fn on_device_removed(&mut self, device: impl Device) {
@@ -264,7 +270,23 @@ impl State {
                 tablet_seat.clear_tools();
             }
         }
-        if device.has_capability(DeviceCapability::Touch) && self.niri.touch.is_empty() {
+
+        self.refresh_wayland_device_caps();
+    }
+
+    /// Updates the Wayland devices (e.g. `wl_touch`) for necessary capabilities.
+    pub fn refresh_wayland_device_caps(&mut self) {
+        let touch_cap_needed =
+            !self.niri.touch.is_empty() || self.niri.remote_desktop.needs_touch_cap();
+        if touch_cap_needed {
+            if self.niri.seat.get_touch().is_none() {
+                trace!("Adding wl_touch to wl_seat");
+                self.niri.seat.add_touch();
+            }
+        } else {
+            if self.niri.seat.get_touch().is_some() {
+                trace!("Removing wl_touch from wl_seat");
+            }
             self.niri.seat.remove_touch();
         }
     }
diff --git a/src/input/remote_desktop_backend.rs b/src/input/remote_desktop_backend.rs
new file mode 100644
index 00000000..9163ea3e
--- /dev/null
+++ b/src/input/remote_desktop_backend.rs
@@ -0,0 +1,282 @@
+//! Input backend for emulated input events received directly via `org.gnome.Mutter.RemoteDesktop`
+//! without EI.
+
+use smithay::backend::input::{
+    AbsolutePositionEvent, Axis, AxisRelativeDirection, AxisSource, ButtonState, Device,
+    DeviceCapability, Event, InputBackend, KeyState, KeyboardKeyEvent, Keycode, PointerAxisEvent,
+    PointerButtonEvent, PointerMotionAbsoluteEvent, PointerMotionEvent, TouchCancelEvent,
+    TouchDownEvent, TouchEvent, TouchFrameEvent, TouchMotionEvent, TouchUpEvent, UnusedEvent,
+};
+use smithay::output::Output;
+use smithay::utils::Point;
+
+use crate::input::backend_ext::NiriInputDevice;
+use crate::niri::State;
+use crate::utils::RemoteDesktopSessionId;
+
+pub struct RdInputBackend;
+
+#[derive(Clone, Debug, Hash, Eq, PartialEq)]
+pub struct RdVirtualDevice {
+    /// Remote desktop session ID
+    pub session_id: RemoteDesktopSessionId,
+}
+
+impl InputBackend for RdInputBackend {
+    type Device = RdVirtualDevice;
+
+    type KeyboardKeyEvent = RdEventAdapter<RdKeyboardKeyEvent>;
+
+    type PointerAxisEvent = RdEventAdapter<RdPointerAxisEvent>;
+    type PointerButtonEvent = RdEventAdapter<RdPointerButtonEvent>;
+    type PointerMotionEvent = RdEventAdapter<RdPointerMotionEvent>;
+    type PointerMotionAbsoluteEvent = RdEventAdapter<RdPointerMotionAbsoluteEvent>;
+
+    type GestureSwipeBeginEvent = UnusedEvent;
+    type GestureSwipeUpdateEvent = UnusedEvent;
+    type GestureSwipeEndEvent = UnusedEvent;
+    type GesturePinchBeginEvent = UnusedEvent;
+    type GesturePinchUpdateEvent = UnusedEvent;
+    type GesturePinchEndEvent = UnusedEvent;
+    type GestureHoldBeginEvent = UnusedEvent;
+    type GestureHoldEndEvent = UnusedEvent;
+
+    type TouchDownEvent = RdEventAdapter<RdTouchEvent<RdAbsolutePosition>>;
+    type TouchMotionEvent = RdEventAdapter<RdTouchEvent<RdAbsolutePosition>>;
+    type TouchUpEvent = RdEventAdapter<RdTouchEvent<()>>;
+    type TouchCancelEvent = RdEventAdapter<RdTouchEvent<()>>;
+    type TouchFrameEvent = RdEventAdapter<RdTouchEvent<()>>;
+
+    type TabletToolAxisEvent = UnusedEvent;
+    type TabletToolProximityEvent = UnusedEvent;
+    type TabletToolTipEvent = UnusedEvent;
+    type TabletToolButtonEvent = UnusedEvent;
+
+    type SwitchToggleEvent = UnusedEvent;
+
+    type SpecialEvent = UnusedEvent;
+}
+
+impl Device for RdVirtualDevice {
+    fn id(&self) -> String {
+        format!("Remote desktop virtual device {}", self.session_id)
+    }
+
+    fn name(&self) -> String {
+        String::from("Remote desktop virtual device")
+    }
+
+    fn has_capability(&self, capability: DeviceCapability) -> bool {
+        // TODO: only actual selected capabilities?
+        matches!(
+            capability,
+            DeviceCapability::Keyboard | DeviceCapability::Pointer | DeviceCapability::Touch
+        )
+    }
+
+    fn usb_id(&self) -> Option<(u32, u32)> {
+        None
+    }
+
+    fn syspath(&self) -> Option<std::path::PathBuf> {
+        None
+    }
+}
+
+impl NiriInputDevice for RdVirtualDevice {
+    fn output(&self, _state: &State) -> Option<Output> {
+        // This would map local output coordinates to global output
+        // coordinates if devices were per-output.
+        None
+    }
+}
+
+pub struct RdEventAdapter<Ev> {
+    /// Remote desktop session ID
+    pub session_id: RemoteDesktopSessionId,
+    /// Timestamp in microseconds
+    pub time: u64,
+    pub inner: Ev,
+}
+
+impl<Ev> Event<RdInputBackend> for RdEventAdapter<Ev> {
+    fn time(&self) -> u64 {
+        self.time
+    }
+
+    fn device(&self) -> <RdInputBackend as InputBackend>::Device {
+        RdVirtualDevice {
+            session_id: self.session_id,
+        }
+    }
+}
+
+pub struct RdKeyboardKeyEvent {
+    /// X11 keycode
+    pub keycode: Keycode,
+    pub state: KeyState,
+}
+
+impl KeyboardKeyEvent<RdInputBackend> for RdEventAdapter<RdKeyboardKeyEvent> {
+    fn key_code(&self) -> Keycode {
+        self.inner.keycode
+    }
+
+    fn state(&self) -> KeyState {
+        self.inner.state
+    }
+
+    fn count(&self) -> u32 {
+        // No idea
+        1
+    }
+}
+
+pub struct RdPointerAxisEvent {
+    /// Note: set to AxisSource::Wheel for discrete axis events
+    pub source: AxisSource,
+    /// Continuous scrolling, like on a touchpad.
+    pub delta: Option<(f64, f64)>,
+    /// 120-notch scrolling, like on a traditional mouse wheel.
+    pub discrete: Option<(i32, i32)>,
+}
+
+fn tuple_axis<T>(tuple: (T, T), axis: Axis) -> T {
+    match axis {
+        Axis::Horizontal => tuple.0,
+        Axis::Vertical => tuple.1,
+    }
+}
+
+impl PointerAxisEvent<RdInputBackend> for RdEventAdapter<RdPointerAxisEvent> {
+    // TODO: test on both continuous and wheel
+    fn amount(&self, axis: Axis) -> Option<f64> {
+        Some(tuple_axis(self.inner.delta?, axis))
+    }
+
+    fn amount_v120(&self, axis: Axis) -> Option<f64> {
+        // TODO: divide by 120?
+        Some(tuple_axis(self.inner.discrete?, axis) as f64)
+    }
+
+    fn source(&self) -> AxisSource {
+        self.inner.source
+    }
+
+    fn relative_direction(&self, _axis: Axis) -> AxisRelativeDirection {
+        AxisRelativeDirection::Identical
+    }
+}
+
+pub struct RdPointerButtonEvent {
+    /// Evdev button code
+    pub button: i32,
+    /// True = pressed, false = released
+    pub state: bool,
+}
+
+impl PointerButtonEvent<RdInputBackend> for RdEventAdapter<RdPointerButtonEvent> {
+    fn button_code(&self) -> u32 {
+        self.inner.button as u32
+    }
+
+    fn state(&self) -> ButtonState {
+        match self.inner.state {
+            false => ButtonState::Released,
+            true => ButtonState::Pressed,
+        }
+    }
+}
+
+pub struct RdPointerMotionEvent {
+    pub dx: f64,
+    pub dy: f64,
+}
+
+impl PointerMotionEvent<RdInputBackend> for RdEventAdapter<RdPointerMotionEvent> {
+    fn delta_x(&self) -> f64 {
+        self.inner.dx
+    }
+
+    fn delta_y(&self) -> f64 {
+        self.inner.dy
+    }
+
+    // Virtual pointer impl does this
+    fn delta_x_unaccel(&self) -> f64 {
+        self.inner.dx
+    }
+
+    fn delta_y_unaccel(&self) -> f64 {
+        self.inner.dy
+    }
+}
+
+pub struct RdPointerMotionAbsoluteEvent(pub RdAbsolutePosition);
+
+impl AbsolutePositionEvent<RdInputBackend> for RdEventAdapter<RdPointerMotionAbsoluteEvent> {
+    // Basically unused
+    fn x(&self) -> f64 {
+        self.inner.0.pos.x
+    }
+
+    fn y(&self) -> f64 {
+        self.inner.0.pos.y
+    }
+
+    // Position in global bounding rectangle
+    fn x_transformed(&self, width: i32) -> f64 {
+        self.inner.0.pos.x * width as f64
+    }
+
+    fn y_transformed(&self, height: i32) -> f64 {
+        self.inner.0.pos.y * height as f64
+    }
+}
+
+impl PointerMotionAbsoluteEvent<RdInputBackend> for RdEventAdapter<RdPointerMotionAbsoluteEvent> {}
+
+pub struct RdTouchEvent<Extra> {
+    pub slot: u32,
+    pub extra: Extra,
+}
+
+/// [`Point`] kind for points represented by numbers between 0 and 1.
+pub struct UnitIntervalPointKind;
+
+pub struct RdAbsolutePosition {
+    /// Absolute position in the global bounding rectangle.
+    pub pos: Point<f64, UnitIntervalPointKind>,
+}
+
+impl<Extra> TouchEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<Extra>> {
+    fn slot(&self) -> smithay::backend::input::TouchSlot {
+        Some(self.inner.slot).into()
+    }
+}
+
+impl AbsolutePositionEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<RdAbsolutePosition>> {
+    // Basically unused
+    fn x(&self) -> f64 {
+        self.inner.extra.pos.x
+    }
+
+    fn y(&self) -> f64 {
+        self.inner.extra.pos.y
+    }
+
+    // Position in global bounding rectangle
+    fn x_transformed(&self, width: i32) -> f64 {
+        self.inner.extra.pos.x * width as f64
+    }
+
+    fn y_transformed(&self, height: i32) -> f64 {
+        self.inner.extra.pos.y * height as f64
+    }
+}
+
+impl TouchDownEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<RdAbsolutePosition>> {}
+impl TouchMotionEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<RdAbsolutePosition>> {}
+impl TouchUpEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<()>> {}
+impl TouchCancelEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<()>> {}
+impl TouchFrameEvent<RdInputBackend> for RdEventAdapter<RdTouchEvent<()>> {}
diff --git a/src/lib.rs b/src/lib.rs
index d5168386..b94352f5 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -17,6 +17,8 @@ pub mod layer;
 pub mod layout;
 pub mod niri;
 pub mod protocols;
+#[cfg(feature = "xdp-gnome-remote-desktop")]
+pub mod remote_desktop;
 pub mod render_helpers;
 pub mod rubber_band;
 #[cfg(feature = "xdp-gnome-screencast")]
diff --git a/src/niri.rs b/src/niri.rs
index aef828f6..62f8e9b9 100644
--- a/src/niri.rs
+++ b/src/niri.rs
@@ -149,6 +149,8 @@ use crate::protocols::output_management::OutputManagementManagerState;
 use crate::protocols::screencopy::{Screencopy, ScreencopyBuffer, ScreencopyManagerState};
 use crate::protocols::virtual_pointer::VirtualPointerManagerState;
 use crate::render_helpers::debug::push_opaque_regions;
+#[cfg(feature = "xdp-gnome-remote-desktop")]
+use crate::remote_desktop::RemoteDesktopState;
 use crate::render_helpers::primary_gpu_texture::PrimaryGpuTextureRenderElement;
 use crate::render_helpers::renderer::NiriRenderer;
 use crate::render_helpers::solid_color::{SolidColorBuffer, SolidColorRenderElement};
@@ -261,8 +263,13 @@ pub struct Niri {
     /// startup, libinput will immediately send a closed event.
     pub is_lid_closed: bool,
 
+    /// Tracked libinput devices.
     pub devices: HashSet<input::Device>,
+
+    /// Tracked libinput tablet devices.
     pub tablets: HashMap<input::Device, TabletData>,
+
+    /// Tracked libinput touch devices.
     pub touch: HashSet<input::Device>,
 
     // Smithay state.
@@ -413,6 +420,9 @@ pub struct Niri {
 
     #[cfg(feature = "xdp-gnome-screencast")]
     pub casting: Screencasting,
+
+    #[cfg(feature = "xdp-gnome-remote-desktop")]
+    pub remote_desktop: RemoteDesktopState,
 }
 
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
@@ -692,6 +702,7 @@ impl KeyboardFocus {
 }
 
 pub struct State {
+    /// The backend for input events and graphical output.
     pub backend: Backend,
     pub niri: Niri,
 }
@@ -2567,6 +2578,9 @@ impl Niri {
 
             #[cfg(feature = "xdp-gnome-screencast")]
             casting: screencasting,
+
+            #[cfg(feature = "xdp-gnome-remote-desktop")]
+            remote_desktop: RemoteDesktopState::default(),
         };
 
         niri.reset_pointer_inactivity_timer();
diff --git a/src/remote_desktop.rs b/src/remote_desktop.rs
new file mode 100644
index 00000000..997d267c
--- /dev/null
+++ b/src/remote_desktop.rs
@@ -0,0 +1,790 @@
+//! Module containing the parts of the implementation of remote desktop that need global state,
+//! including EIS (=emulated input server).
+
+use std::collections::HashMap;
+
+use calloop::RegistrationToken;
+use enumflags2::BitFlags;
+use reis::calloop::{EisRequestSource, EisRequestSourceEvent};
+use reis::ei::device::DeviceType;
+use reis::ei::keyboard::KeymapType;
+use reis::eis;
+use reis::event::{DeviceCapability, Region};
+use reis::request::{Device as EiDevice, EisRequest, Seat as EiSeat};
+use smithay::backend::input::{KeyState, Keycode};
+use smithay::input::keyboard::{xkb, KeymapFile, Keysym, ModifiersState, SerializedMods};
+use smithay::utils::{Logical, Size};
+
+use crate::dbus::mutter_remote_desktop::{MutterXdpDeviceType, RemoteDesktopDBusToCalloop};
+use crate::input::eis_backend::{
+    AbsolutePositionEventExtra, EisEventAdapter, EisInputBackend, PressedCount, ScrollFrame,
+    TouchFrame,
+};
+use crate::input::remote_desktop_backend::{RdEventAdapter, RdInputBackend, RdKeyboardKeyEvent};
+use crate::niri::State;
+use crate::utils::RemoteDesktopSessionId;
+
+/// Processes an input event with the EIS event adapter.
+macro_rules! process_event {
+    ($global_state:expr, $context_state:expr, $inner:expr, $ident:ident) => {{
+        process_event!($global_state, $context_state, $inner, $ident, ())
+    }};
+    ($global_state:expr, $context_state:expr, $inner:expr, $ident:ident, $extra:expr) => {{
+        $global_state.process_input_event(InputEvent::$ident {
+            event: EisEventAdapter {
+                session_id: $context_state.session_id,
+                inner: $inner,
+                extra: $extra,
+            },
+        });
+    }};
+}
+
+type InputEvent = smithay::backend::input::InputEvent<EisInputBackend>;
+
+/// Child struct of the global `State` struct
+#[derive(Default)]
+pub struct RemoteDesktopState {
+    /// Active EI sessions.
+    active_ei_sessions: HashMap<RemoteDesktopSessionId, RegistrationToken>,
+
+    /// Counts the number of remote desktop sessions requiring touch capability on the seat.
+    ///
+    /// Modified by both [`crate::dbus::mutter_remote_desktop`] (D-Bus) and EIS.
+    pub touch_session_counter: usize,
+}
+impl RemoteDesktopState {
+    /// Whether touch capability on the seat is needed.
+    pub fn needs_touch_cap(&self) -> bool {
+        self.touch_session_counter > 0
+    }
+}
+
+/// The state for an EI connection.
+struct ContextState {
+    seat: Option<EiSeat>,
+    /// The number of keys pressed on all devices in the seat.
+    key_counter: u32,
+    exposed_device_types: BitFlags<MutterXdpDeviceType>,
+    session_id: RemoteDesktopSessionId,
+    /// A scroll frame being filled in by the different scroll events. Assumes there is only
+    /// one device that can emit scroll levents.
+    scroll_frame: Option<ScrollFrame>,
+    /// Whether to send a [`smithay::backend::input::TouchFrameEvent`] when an EIS frame
+    /// request is received.
+    next_frame_touch: bool,
+    // TODO: these are stored for reload integration. e.g. keymap has to be reloaded by recreating
+    // the ei_device completely
+    keyboard_device: Option<EiDevice>,
+    mouse_device: Option<EiDevice>,
+    touch_device: Option<EiDevice>,
+    regions: Vec<Region>,
+    global_extent: Size<f64, Logical>,
+}
+
+impl State {
+    pub fn on_remote_desktop_msg_from_dbus(&mut self, msg: RemoteDesktopDBusToCalloop) {
+        match msg {
+            RemoteDesktopDBusToCalloop::RemoveEisHandler { session_id } => {
+                if let Some(token) = self
+                    .niri
+                    .remote_desktop
+                    .active_ei_sessions
+                    .remove(&session_id)
+                {
+                    self.niri.event_loop.remove(token);
+                } else {
+                    warn!(
+                        "RemoteDesktop RemoveEisHandler: Invalid session ID {}",
+                        session_id
+                    )
+                }
+            }
+            RemoteDesktopDBusToCalloop::NewEisContext {
+                session_id,
+                ctx,
+                exposed_device_types,
+            } => {
+                // This lives with the closure
+                let mut context_state = ContextState {
+                    seat: None,
+                    key_counter: 0,
+                    exposed_device_types,
+                    session_id,
+                    scroll_frame: None,
+                    next_frame_touch: false,
+                    keyboard_device: None,
+                    mouse_device: None,
+                    touch_device: None,
+                    regions: Vec::new(),
+                    global_extent: Size::new(0., 0.),
+                };
+
+                let token = self
+                    .niri
+                    .event_loop
+                    .insert_source(
+                        EisRequestSource::new(ctx, 1),
+                        move |event, connection, state| {
+                            match handle_eis_request_source_event(
+                                event,
+                                connection,
+                                state,
+                                &mut context_state,
+                            ) {
+                                Ok(post_action) => {
+                                    if post_action != calloop::PostAction::Continue {
+                                        debug!("EIS connection {post_action:?}");
+                                    }
+                                    Ok(post_action)
+                                }
+                                Err(err) => {
+                                    // Always Ok because we never want to error out of the entire
+                                    // event loop
+                                    warn!("Error while flushing connection: {err}");
+                                    Ok(calloop::PostAction::Remove)
+                                }
+                            }
+                        },
+                    )
+                    .unwrap();
+                self.niri
+                    .remote_desktop
+                    .active_ei_sessions
+                    .insert(session_id, token);
+            }
+            RemoteDesktopDBusToCalloop::EmulateInput(event) => self.process_input_event(event),
+            RemoteDesktopDBusToCalloop::EmulateKeysym {
+                keysym,
+                state,
+                session_id,
+                time,
+            } => {
+                let keysym = Keysym::from(keysym);
+
+                let keyboard_handle = self.niri.seat.get_keyboard().unwrap();
+
+                let prev_mods_state = keyboard_handle.modifier_state();
+
+                let Some((keycode, mod_mask, mods_state)) =
+                    keyboard_handle.with_xkb_state(self, |context| {
+                        let xkb = context.xkb().lock().unwrap();
+
+                        // SAFETY: the state's ref count isn't increased
+                        let xkb_state = unsafe { xkb.state() };
+
+                        // SAFETY: the keymap's ref count isn't increased
+                        let keymap = unsafe { xkb.keymap() };
+
+                        let (keycode, mod_mask) = keysym_to_keycode(xkb_state, keymap, keysym)?;
+
+                        let mut new_serialized = prev_mods_state.serialized;
+                        match state {
+                            KeyState::Pressed => new_serialized.depressed |= mod_mask,
+                            KeyState::Released => new_serialized.depressed &= !mod_mask,
+                        }
+
+                        // Turn into `ModifiersState`
+                        let mods_state = deserialize_mods(new_serialized, keymap);
+
+                        Some((keycode, mod_mask, mods_state))
+                    })
+                else {
+                    // TODO: update when multi keyboard layouts/groups is supported in search
+                    warn!(
+                        "Couldn't find keycode for keysym {} (raw {}) in the current keyboard layout",
+                        keysym.name().unwrap_or_default(),
+                        keysym.raw()
+                    );
+                    return;
+                };
+
+                debug!(
+                    "{} Emulating keysym={:12} X11 keycode={: <3} depressed={:#04b}, latched={:#04b}, locked={:#04b}, mod_mask={mod_mask:#04b}, prev mod mask={:#04b}",
+                    match state {
+                        KeyState::Pressed => "",
+                        KeyState::Released => ""
+                    },
+                    keysym.name().unwrap_or_default(), // Used only for debug
+                    keycode.raw(),
+                    mods_state.serialized.depressed,
+                    mods_state.serialized.latched,
+                    mods_state.serialized.locked,
+                    prev_mods_state.serialized.depressed
+                      | prev_mods_state.serialized.latched
+                      | prev_mods_state.serialized.locked,
+                );
+
+                let modifiers_changed = keyboard_handle.set_modifier_state(mods_state);
+                if modifiers_changed != 0 {
+                    keyboard_handle.advertise_modifier_state(self);
+                }
+
+                self.process_input_event::<RdInputBackend>(
+                    smithay::backend::input::InputEvent::Keyboard {
+                        event: RdEventAdapter {
+                            session_id,
+                            time,
+                            inner: RdKeyboardKeyEvent { keycode, state },
+                        },
+                    },
+                );
+            }
+            RemoteDesktopDBusToCalloop::IncTouchSession => {
+                self.niri.remote_desktop.touch_session_counter += 1;
+
+                self.refresh_wayland_device_caps();
+            }
+            RemoteDesktopDBusToCalloop::DecTouchSession => {
+                self.niri.remote_desktop.touch_session_counter = self
+                    .niri
+                    .remote_desktop
+                    .touch_session_counter
+                    .saturating_sub(1);
+
+                self.refresh_wayland_device_caps();
+            }
+        }
+    }
+}
+
+fn handle_eis_request_source_event(
+    event: Result<EisRequestSourceEvent, reis::Error>,
+    connection: &mut reis::request::Connection,
+    global_state: &mut State,
+    context_state: &mut ContextState,
+) -> Result<calloop::PostAction, std::io::Error> {
+    Ok(match event {
+        Ok(event) => match event {
+            EisRequestSourceEvent::Connected => {
+                debug!("EIS connected!");
+                if !connection.has_interface("ei_seat") || !connection.has_interface("ei_device") {
+                    connection.disconnected(
+                        eis::connection::DisconnectReason::Protocol,
+                        "Need `ei_seat` and `ei_device`",
+                    );
+                    connection.flush()?;
+                    return Ok(calloop::PostAction::Remove);
+                }
+
+                let seat = connection.add_seat(
+                    Some("default"),
+                    MutterXdpDeviceType::to_reis_capabilities(context_state.exposed_device_types),
+                );
+
+                context_state.seat = Some(seat);
+
+                connection.flush()?;
+                calloop::PostAction::Continue
+            }
+            EisRequestSourceEvent::Request(request) => {
+                debug!("EIS request! {:#?}", request);
+                let post_action =
+                    handle_eis_request(request, connection, global_state, context_state);
+                connection.flush()?;
+                post_action
+            }
+        },
+        Err(err) => {
+            warn!("EIS protocol error: {err}");
+            connection.disconnected(
+                eis::connection::DisconnectReason::Protocol,
+                &err.to_string(),
+            );
+            connection.flush()?;
+            calloop::PostAction::Remove
+        }
+    })
+}
+
+// TODO: send ei_keyboard.modifiers when other keyboards change modifier state?
+// TODO: recreate keyboard with new keymaps
+// ^ Waiting for https://github.com/Smithay/smithay/issues/1776
+
+/// Creates an EI keyboard if the capabilities match.
+///
+/// The device must be [`EiDevice::resumed`] for clients to request to
+/// [`EisRequest::DeviceStartEmulating`] input.
+fn create_ei_keyboard(
+    seat: &EiSeat,
+    capabilities: BitFlags<DeviceCapability>,
+    connection: &mut reis::request::Connection,
+    global_state: &mut State,
+) -> Option<EiDevice> {
+    (capabilities.contains(DeviceCapability::Keyboard) && connection.has_interface("ei_keyboard"))
+        .then(|| {
+            seat.add_device(
+                Some("keyboard"),
+                DeviceType::Virtual,
+                DeviceCapability::Keyboard.into(),
+                |device| {
+                    let keyboard: reis::eis::Keyboard = device
+                        .interface()
+                        .expect("Should exist because it was just defined");
+
+                    let file = global_state
+                        .niri
+                        .seat
+                        .get_keyboard()
+                        .unwrap()
+                        .with_xkb_state(global_state, |context| {
+                            let xkb = context.xkb().lock().unwrap();
+
+                            // SAFETY: the keymap's ref count isn't increased
+                            let keymap = unsafe { xkb.keymap() };
+                            KeymapFile::new(keymap)
+                        });
+
+                    // > The fd must be mapped with MAP_PRIVATE by the recipient, as MAP_SHARED may fail.
+                    //
+                    // EI protocol allows us to use anonymous, sealed files.
+                    file.with_fd(true, |fd, size| {
+                        // Smithay also does this cast
+                        keyboard.keymap(KeymapType::Xkb, size as u32, fd);
+                    })
+                    .unwrap();
+                    debug!("Sent keymap file");
+                },
+            )
+        })
+}
+
+/// Creates an EI mouse if the capabilities match.
+///
+/// The device must be [`EiDevice::resumed`] for clients to request to
+/// [`EisRequest::DeviceStartEmulating`] input.
+fn create_ei_mouse(
+    seat: &EiSeat,
+    capabilities: BitFlags<DeviceCapability>,
+    connection: &mut reis::request::Connection,
+) -> Option<EiDevice> {
+    let mut mouse_capabilities = BitFlags::empty();
+
+    let mut check_mouse_cap = |capability, interface| {
+        // We check for the interfaces' existence because the client may send
+        // a 0xffffffffffffffff and then any events we send to the sub-interfaces will be
+        // protocol violations.
+        if capabilities.contains(capability) && connection.has_interface(interface) {
+            mouse_capabilities |= capability;
+        }
+    };
+
+    check_mouse_cap(DeviceCapability::Pointer, "ei_pointer");
+    check_mouse_cap(DeviceCapability::Scroll, "ei_scroll");
+    check_mouse_cap(DeviceCapability::Button, "ei_button");
+    check_mouse_cap(DeviceCapability::PointerAbsolute, "ei_pointer_absolute");
+
+    (!mouse_capabilities.is_empty()).then(|| {
+        seat.add_device(
+            Some("mouse"),
+            DeviceType::Virtual,
+            mouse_capabilities,
+            |_| {},
+        )
+    })
+}
+
+/// Creates an EI keyboard if the capabilities match.
+///
+/// The device must be [`EiDevice::resumed`] for clients to request to
+/// [`EisRequest::DeviceStartEmulating`] input.
+fn create_ei_touchscreen(
+    seat: &EiSeat,
+    capabilities: BitFlags<DeviceCapability>,
+    connection: &mut reis::request::Connection,
+) -> Option<EiDevice> {
+    (capabilities.contains(DeviceCapability::Touch) && connection.has_interface("ei_touchscreen"))
+        .then(|| {
+            seat.add_device(
+                Some("touchscreen"),
+                DeviceType::Virtual,
+                DeviceCapability::Touch.into(),
+                |_| {},
+            )
+        })
+}
+
+/// (Re)creates EI devices.
+fn create_ei_devices(
+    connection: &mut reis::request::Connection,
+    global_state: &mut State,
+    context_state: &mut ContextState,
+    seat: EiSeat,
+    capabilities: BitFlags<DeviceCapability, u64>,
+) {
+    let mut touch_device_count_delta = if context_state.touch_device.is_some() {
+        -1
+    } else {
+        0
+    };
+
+    for old_device_slot in [
+        &mut context_state.keyboard_device,
+        &mut context_state.mouse_device,
+        &mut context_state.touch_device,
+    ]
+    .into_iter()
+    {
+        if let Some(old_device) = old_device_slot {
+            old_device.remove();
+            *old_device_slot = None;
+        }
+    }
+
+    if let Some(device) = create_ei_keyboard(&seat, capabilities, connection, global_state) {
+        advertise_regions(&device, &context_state.regions);
+        device.resumed();
+        context_state.keyboard_device = Some(device);
+    }
+
+    if let Some(device) = create_ei_mouse(&seat, capabilities, connection) {
+        advertise_regions(&device, &context_state.regions);
+        device.resumed();
+        context_state.mouse_device = Some(device);
+    }
+
+    if let Some(device) = create_ei_touchscreen(&seat, capabilities, connection) {
+        advertise_regions(&device, &context_state.regions);
+        device.resumed();
+        context_state.touch_device = Some(device);
+
+        touch_device_count_delta += 1;
+    }
+
+    global_state.niri.remote_desktop.touch_session_counter = global_state
+        .niri
+        .remote_desktop
+        .touch_session_counter
+        .saturating_add_signed(touch_device_count_delta);
+    if touch_device_count_delta != 0 {
+        global_state.refresh_wayland_device_caps();
+    }
+}
+
+/// Advertises regions on EI devices.
+fn advertise_regions(device: &EiDevice, regions: &[Region]) {
+    for region in regions {
+        device.device().region(
+            region.x,
+            region.y,
+            region.width,
+            region.height,
+            region.scale,
+        );
+        if let Some(mapping_id) = &region.mapping_id {
+            device.device().region_mapping_id(mapping_id);
+        }
+    }
+}
+
+fn handle_eis_request(
+    request: reis::request::EisRequest,
+    connection: &mut reis::request::Connection,
+    global_state: &mut State,
+    context_state: &mut ContextState,
+) -> calloop::PostAction {
+    match request {
+        EisRequest::Disconnect => {
+            return calloop::PostAction::Remove;
+        }
+        EisRequest::Bind(reis::request::Bind { seat, capabilities }) => {
+            if capabilities
+                & MutterXdpDeviceType::to_reis_capabilities(context_state.exposed_device_types)
+                != capabilities
+            {
+                connection.disconnected(
+                    eis::connection::DisconnectReason::Value,
+                    "Binding to invalid capabilities",
+                );
+                return calloop::PostAction::Remove;
+            }
+
+            // TODO: Why not combine everything into a single device?
+
+            create_ei_devices(connection, global_state, context_state, seat, capabilities);
+        }
+
+        EisRequest::DeviceStartEmulating(inner) => {
+            let returned_sequence = inner.sequence.wrapping_add(1);
+            inner.device.start_emulating(returned_sequence);
+        }
+        EisRequest::DeviceStopEmulating(inner) => {
+            inner.device.stop_emulating();
+        }
+
+        EisRequest::PointerMotion(inner) => {
+            process_event!(global_state, context_state, inner, PointerMotion)
+        }
+
+        EisRequest::PointerMotionAbsolute(inner) => {
+            process_event!(
+                global_state,
+                context_state,
+                inner,
+                PointerMotionAbsolute,
+                AbsolutePositionEventExtra {
+                    global_extent: context_state.global_extent
+                }
+            )
+        }
+
+        EisRequest::Button(inner) => {
+            process_event!(global_state, context_state, inner, PointerButton)
+        }
+
+        EisRequest::ScrollDelta(inner) => {
+            let scroll_frame = context_state
+                .scroll_frame
+                .get_or_insert_with(Default::default);
+            scroll_frame.delta = Some((inner.dx, inner.dy));
+        }
+
+        EisRequest::ScrollStop(inner) => {
+            let scroll_frame = context_state
+                .scroll_frame
+                .get_or_insert_with(Default::default);
+            scroll_frame.stop = Some(((inner.x, inner.y), false));
+        }
+
+        EisRequest::ScrollCancel(inner) => {
+            let scroll_frame = context_state
+                .scroll_frame
+                .get_or_insert_with(Default::default);
+            scroll_frame.stop = Some(((inner.x, inner.y), true));
+        }
+
+        EisRequest::ScrollDiscrete(inner) => {
+            let scroll_frame = context_state
+                .scroll_frame
+                .get_or_insert_with(Default::default);
+            scroll_frame.discrete = Some((inner.discrete_dx, inner.discrete_dy));
+        }
+
+        EisRequest::Frame(inner) => {
+            if let Some(scroll_frame) = context_state.scroll_frame.take() {
+                process_event!(
+                    global_state,
+                    context_state,
+                    inner.clone(),
+                    PointerAxis,
+                    scroll_frame
+                )
+            }
+
+            if context_state.next_frame_touch {
+                process_event!(
+                    global_state,
+                    context_state,
+                    inner.clone(),
+                    TouchFrame,
+                    TouchFrame
+                );
+                context_state.next_frame_touch = false;
+            }
+        }
+
+        EisRequest::KeyboardKey(inner) => {
+            // TODO: Reis should put all "framed" requests in EisRequest::Frame, because it's
+            // buffering them anyway.
+
+            // TODO: This is super naive. Set<keycode>? Map<keycode, count>?
+            match inner.state {
+                reis::ei::keyboard::KeyState::Released => {
+                    context_state.key_counter = context_state.key_counter.saturating_sub(1)
+                }
+                reis::ei::keyboard::KeyState::Press => context_state.key_counter += 1,
+            }
+
+            process_event!(
+                global_state,
+                context_state,
+                inner,
+                Keyboard,
+                PressedCount(context_state.key_counter)
+            );
+        }
+
+        EisRequest::TouchDown(inner) => {
+            process_event!(
+                global_state,
+                context_state,
+                inner,
+                TouchDown,
+                AbsolutePositionEventExtra {
+                    global_extent: context_state.global_extent
+                }
+            );
+            context_state.next_frame_touch = true;
+        }
+        EisRequest::TouchMotion(inner) => {
+            process_event!(
+                global_state,
+                context_state,
+                inner,
+                TouchMotion,
+                AbsolutePositionEventExtra {
+                    global_extent: context_state.global_extent
+                }
+            );
+            context_state.next_frame_touch = true;
+        }
+        EisRequest::TouchUp(inner) => {
+            process_event!(global_state, context_state, inner, TouchUp);
+            context_state.next_frame_touch = true;
+        }
+        EisRequest::TouchCancel(inner) => {
+            process_event!(global_state, context_state, inner, TouchCancel);
+            context_state.next_frame_touch = true;
+        }
+    }
+
+    calloop::PostAction::Continue
+}
+
+/// Reconstructs symbolic meanings of modifiers ([`ModifiersState`]) from serialized modifiers.
+///
+/// The modifiers are active when they're present in any of the masks (depressed, latched or
+/// locked).
+///
+/// This is the inverse of [`ModifiersState::serialize_back`].
+fn deserialize_mods(serialized: SerializedMods, keymap: &xkb::Keymap) -> ModifiersState {
+    let mod_mask = serialized.depressed | serialized.latched | serialized.locked;
+
+    let is_index_active = |index| (mod_mask & (1u32 << index)) != 0;
+    let is_mod_active = |name| {
+        let index = keymap.mod_get_index(name);
+        if index == xkb::MOD_INVALID {
+            false
+        } else {
+            is_index_active(index)
+        }
+    };
+
+    ModifiersState {
+        caps_lock: is_mod_active(xkb::MOD_NAME_CAPS),
+        num_lock: is_mod_active(xkb::MOD_NAME_NUM),
+        ctrl: is_mod_active(xkb::MOD_NAME_CTRL),
+        alt: is_mod_active(xkb::MOD_NAME_ALT),
+        shift: is_mod_active(xkb::MOD_NAME_SHIFT),
+        logo: is_mod_active(xkb::MOD_NAME_LOGO),
+        iso_level3_shift: is_mod_active(xkb::MOD_NAME_ISO_LEVEL3_SHIFT),
+        iso_level5_shift: is_mod_active(xkb::MOD_NAME_MOD3),
+        serialized,
+    }
+}
+
+/// Scans the given `keymap` and returns the first keycode (as u32) that produces `keysym` in any
+/// level. If none found, returns `None`.
+// TODO: Try other groups too, because it's basically trivial to switch groups with
+// wl_keyboard.modifiers
+fn keysym_to_keycode(
+    state: &xkb::State,
+    keymap: &xkb::Keymap,
+    target_keysym: Keysym,
+) -> Option<(Keycode, xkb::ModMask)> {
+    let min = keymap.min_keycode().raw();
+    let max = keymap.max_keycode().raw();
+
+    let layout_index = state.serialize_layout(xkb::STATE_LAYOUT_EFFECTIVE);
+
+    for keycode in min..=max {
+        let keycode = Keycode::new(keycode);
+
+        // Skip unused keycodes
+        if keymap.key_get_name(keycode).is_none() {
+            continue;
+        }
+
+        let num_levels = keymap.num_levels_for_key(keycode, layout_index);
+        for level_index in 0..num_levels {
+            let syms = keymap.key_get_syms_by_level(keycode, layout_index, level_index);
+
+            if syms != [target_keysym] {
+                // Inequal or nonzero count
+                continue;
+            };
+
+            let mut mod_mask = xkb::ModMask::default();
+            let num_masks = keymap.key_get_mods_for_level(
+                keycode,
+                layout_index,
+                level_index,
+                std::array::from_mut(&mut mod_mask),
+            );
+
+            if num_masks == 0 {
+                error!(
+                    "Couldn't retrieve modifiers for keycode {} and level {}",
+                    keycode.raw(),
+                    level_index + 1
+                );
+                return None;
+            }
+
+            return Some((keycode, mod_mask));
+        }
+    }
+
+    None
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    // Evdev keycode constants from `input-event-codes.h`
+    const KEY_SPACE: u32 = 57;
+    const KEY_Q: u32 = 16;
+    const KEY_A: u32 = 30;
+
+    #[test]
+    fn space_to_keycode() {
+        let ctx = xkb::Context::new(xkb::CONTEXT_NO_FLAGS);
+        let keymap =
+            xkb::Keymap::new_from_names(&ctx, "", "", "us", "", None, xkb::KEYMAP_COMPILE_NO_FLAGS)
+                .expect("Failed to compile keymap");
+        let state = xkb::State::new(&keymap);
+
+        let keysym = Keysym::space;
+        let (keycode, mod_mask) =
+            keysym_to_keycode(&state, &keymap, keysym).expect("Could not find keycodepace");
+
+        assert_eq!(keycode.raw(), KEY_SPACE + 8);
+        assert_eq!(mod_mask, 0);
+    }
+
+    #[test]
+    fn keysym_to_keycode_multilayout() {
+        let ctx = xkb::Context::new(xkb::CONTEXT_NO_FLAGS);
+        let keymap = xkb::Keymap::new_from_names(
+            &ctx,
+            "",
+            "",
+            "us,fr",
+            "",
+            None,
+            xkb::KEYMAP_COMPILE_NO_FLAGS,
+        )
+        .expect("Failed to compile keymap");
+
+        let mut state = xkb::State::new(&keymap);
+
+        // Test the Q key on QWERTY and AZERTY layouts
+        let keysym = Keysym::q;
+
+        let (keycode, mod_mask) =
+            keysym_to_keycode(&state, &keymap, keysym).expect("Could not find keycode");
+
+        assert_eq!(keycode.raw(), KEY_Q + 8);
+        assert_eq!(mod_mask, 0);
+
+        // Wayland clients insert the `group` field of `wl_keyboard.modifiers` into `locked_layout`
+        state.update_mask(0, 0, 0, 0, 0, 1);
+
+        let (keycode, mod_mask) =
+            keysym_to_keycode(&state, &keymap, keysym).expect("Could not find keycode");
+
+        assert_eq!(keycode.raw(), KEY_A + 8);
+        assert_eq!(mod_mask, 0);
+    }
+}
diff --git a/src/screencasting/mod.rs b/src/screencasting/mod.rs
index ca625757..294b33cf 100644
--- a/src/screencasting/mod.rs
+++ b/src/screencasting/mod.rs
@@ -383,22 +383,22 @@ impl State {
 
     pub fn on_screen_cast_msg(&mut self, msg: ScreenCastToNiri) {
         match msg {
-            ScreenCastToNiri::StartCast {
+            ScreenCastToNiri::StartStream {
                 session_id,
                 stream_id,
                 target,
                 cursor_mode,
                 signal_ctx,
             } => {
-                let _span = tracy_client::span!("StartCast");
-                let _span = debug_span!("StartCast", %session_id, %stream_id).entered();
+                let _span = tracy_client::span!("StartStream");
+                let _span = debug_span!("StartStream", %session_id, %stream_id).entered();
 
                 let (target, size, refresh, alpha) = match target {
                     StreamTargetId::Output { name } => {
                         let global_space = &self.niri.global_space;
                         let output = global_space.outputs().find(|out| out.name() == name);
                         let Some(output) = output else {
-                            warn!("error starting screencast: requested output is missing");
+                            warn!("error starting screencast stream: requested output is missing");
                             self.niri.stop_cast(session_id);
                             return;
                         };
@@ -420,7 +420,7 @@ impl State {
                     }
                     StreamTargetId::Window { id } => {
                         let Some((size, refresh)) = self.niri.cast_params_for_window(id) else {
-                            warn!("error starting screencast: requested window is missing");
+                            warn!("error starting screencast stream: requested window is missing");
                             self.niri.stop_cast(session_id);
                             return;
                         };
@@ -431,7 +431,7 @@ impl State {
                 let (gbm, render_formats) = match self.prepare_pw_cast() {
                     Ok(x) => x,
                     Err(err) => {
-                        warn!("error starting screencast: {err:?}");
+                        warn!("error starting screencast stream: {err:?}");
                         self.niri.stop_cast(session_id);
                         return;
                     }
@@ -455,12 +455,15 @@ impl State {
                         self.niri.casting.casts.push(cast);
                     }
                     Err(err) => {
-                        warn!("error starting screencast: {err:?}");
+                        warn!("error starting screencast stream: {err:?}");
                         self.niri.stop_cast(session_id);
                     }
                 }
             }
-            ScreenCastToNiri::StopCast { session_id } => self.niri.stop_cast(session_id),
+            ScreenCastToNiri::StopCast { session_id, reason } => {
+                debug!(%session_id, ?reason, "Handling ScreenCastToNiri::StopCast");
+                self.niri.stop_cast(session_id)
+            }
         }
     }
 }
@@ -727,8 +730,8 @@ impl Niri {
 
             async_io::block_on(async move {
                 iface
-                    .get()
-                    .stop(server.inner(), iface.signal_emitter().clone())
+                    .get_mut()
+                    .stop_from_stopcast(server.inner(), &iface.signal_emitter().clone())
                     .await
             });
         }
diff --git a/src/utils/mod.rs b/src/utils/mod.rs
index 84804a02..7060947e 100644
--- a/src/utils/mod.rs
+++ b/src/utils/mod.rs
@@ -95,6 +95,33 @@ impl Display for CastStreamId {
     }
 }
 
+/// Unique ID for a remote desktop session.
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
+pub struct RemoteDesktopSessionId(u64);
+
+impl RemoteDesktopSessionId {
+    pub fn next() -> Self {
+        static COUNTER: IdCounter = IdCounter::new();
+        Self(COUNTER.next())
+    }
+
+    pub fn get(self) -> u64 {
+        self.0
+    }
+}
+
+impl Display for RemoteDesktopSessionId {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "{}", self.0)
+    }
+}
+
+impl From<u64> for RemoteDesktopSessionId {
+    fn from(value: u64) -> Self {
+        Self(value)
+    }
+}
+
 bitflags! {
     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
     pub struct ResizeEdge: u32 {
