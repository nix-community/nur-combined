diff --git a/lib/modules/manager/nix/extract.spec.ts b/lib/modules/manager/nix/extract.spec.ts
index 23521855009..c761fa96b9a 100644
--- a/lib/modules/manager/nix/extract.spec.ts
+++ b/lib/modules/manager/nix/extract.spec.ts
@@ -1391,4 +1391,111 @@ describe('modules/manager/nix/extract', () => {
     expect(result?.deps).toHaveLength(1);
     expect(result?.deps[0].depName).toBe('nixpkgs');
   });
+
+  it('handles multiple inputs with same name', async () => {
+    const flakeLock = codeBlock`{
+      "nodes": {
+        "nixpkgs": {
+          "locked": {
+            "lastModified": 1720031269,
+            "narHash": "sha256-rwz8NJZV+387rnWpTYcXaRNvzUSnnF9aHONoJIYmiUQ=",
+            "owner": "NixOS",
+            "repo": "nixpkgs",
+            "rev": "9f4128e00b0ae8ec65918efeba59db998750ead6",
+            "type": "github"
+          },
+          "original": {
+            "owner": "NixOS",
+            "ref": "nixos-unstable",
+            "repo": "nixpkgs",
+            "type": "github"
+          }
+        },
+        "nixpkgs_2": {
+          "locked": {
+            "lastModified": 1767379071,
+            "narHash": "sha256-EgE0pxsrW9jp9YFMkHL9JMXxcqi/OoumPJYwf+Okucw=",
+            "owner": "NixOS",
+            "repo": "nixpkgs",
+            "rev": "fb7944c166a3b630f177938e478f0378e64ce108",
+            "type": "github"
+          },
+          "original": {
+            "owner": "NixOS",
+            "ref": "nixos-unstable",
+            "repo": "nixpkgs",
+            "type": "github"
+          }
+        },
+        "root": {
+          "inputs": {
+            "nixpkgs": "nixpkgs_2"
+          }
+        }
+      },
+      "root": "root",
+      "version": 7
+    }`;
+    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+    expect(await extractPackageFile('', 'flake.nix')).toEqual({
+      deps: [
+        {
+          currentValue: 'nixos-unstable',
+          depName: 'nixpkgs',
+          datasource: GitRefsDatasource.id,
+          packageName: 'https://github.com/NixOS/nixpkgs',
+          versioning: nixpkgsVersioning,
+          lockedVersion: 'fb7944c166a3b630f177938e478f0378e64ce108',
+        },
+      ],
+    });
+  });
+
+  it('returns null when node is missing', async () => {
+    const flakeLock = codeBlock`{
+      "nodes": {
+        "root": {
+          "inputs": {
+            "unknown-flake": "unknown-flake"
+          }
+        }
+      },
+      "root": "root",
+      "version": 7
+    }`;
+    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+  });
+
+  it('returns null when root input is not a string', async () => {
+    const flakeLock = codeBlock`{
+      "nodes": {
+        "nixpkgs": {
+          "locked": {
+            "lastModified": 1757068644,
+            "narHash": "sha256-NOrUtIhTkIIumj1E/Rsv1J37Yi3xGStISEo8tZm3KW4=",
+            "owner": "NixOS",
+            "repo": "nixpkgs",
+            "rev": "8eb28adfa3dc4de28e792e3bf49fcf9007ca8ac9",
+            "type": "github"
+          },
+          "original": {
+            "owner": "NixOS",
+            "ref": "nixos-unstable",
+            "repo": "nixpkgs",
+            "type": "github"
+          }
+        },
+        "root": {
+          "inputs": {
+            "nixpkgs": ["nixpkgs"]
+          }
+        }
+      },
+      "root": "root",
+      "version": 7
+    }`;
+    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+  });
 });
diff --git a/lib/modules/manager/nix/extract.ts b/lib/modules/manager/nix/extract.ts
index 6404e030a8e..84f384c6b75 100644
--- a/lib/modules/manager/nix/extract.ts
+++ b/lib/modules/manager/nix/extract.ts
@@ -43,27 +43,34 @@ export async function extractPackageFile(
   }
 
   const flakeLock = flakeLockParsed.data;
-  const rootInputs = flakeLock.nodes.root.inputs;
+  const rootInputs = flakeLock.nodes[flakeLock.root].inputs;
 
   if (!rootInputs) {
     logger.debug(
-      { flakeLockFile, error: flakeLockParsed.error },
-      `flake.lock is missing "root" node`,
+      { flakeLockFile },
+      `root node in flake.lock does not contain inputs, skipping`,
     );
     return null;
   }
 
-  for (const [depName, flakeInput] of Object.entries(flakeLock.nodes)) {
-    // the root input is a magic string for the entrypoint and only references other flake inputs
-    if (depName === 'root') {
+  for (const [depName, nodeName] of Object.entries(rootInputs)) {
+    if (typeof nodeName !== 'string') {
+      logger.debug(
+        { flakeLockFile, nodeName },
+        `input node name is not a string, skipping`,
+      );
       continue;
     }
 
-    // skip all locked and transitivie nodes as they cannot be updated by regular means
-    if (!(depName in rootInputs)) {
+    if (!Object.hasOwn(flakeLock.nodes, nodeName)) {
+      logger.debug(
+        { flakeLockFile, nodeName },
+        `input node not found in flake.lock, skipping`,
+      );
       continue;
     }
 
+    const flakeInput = flakeLock.nodes[nodeName];
     // flakeLocked example: { rev: '56a49ffef2908dad1e9a8adef1f18802bc760962', type: 'github' }
     const flakeLocked = flakeInput.locked;
     // flakeOriginal example: { owner: 'NuschtOS', repo: 'search', type: 'github' }
diff --git a/lib/modules/manager/nix/schema.ts b/lib/modules/manager/nix/schema.ts
index 01b3da431a4..21427a10828 100644
--- a/lib/modules/manager/nix/schema.ts
+++ b/lib/modules/manager/nix/schema.ts
@@ -38,6 +38,7 @@ const NixInput = z.object({
 export const NixFlakeLock = Json.pipe(
   z.object({
     nodes: z.record(z.string(), NixInput),
+    root: z.string(),
     version: z.literal(7),
   }),
 );
