diff --git a/lib/modules/manager/nix/artifacts.spec.ts b/lib/modules/manager/nix/artifacts.spec.ts
index fc0f49063c9..bc1204acf23 100644
--- a/lib/modules/manager/nix/artifacts.spec.ts
+++ b/lib/modules/manager/nix/artifacts.spec.ts
@@ -29,16 +29,9 @@ process.env.CONTAINERBASE = 'true';
 
 const config: UpdateArtifactsConfig = {};
 const lockMaintenanceConfig = { ...config, isLockFileMaintenance: true };
-const updateInputCmd = `nix \
---extra-experimental-features 'nix-command flakes' \
-flake update nixpkgs`;
-const updateInputTokenCmd = `nix \
---extra-experimental-features 'nix-command flakes' \
---extra-access-tokens github.com=token \
-flake update nixpkgs`;
-const lockfileMaintenanceCmd = `nix \
---extra-experimental-features 'nix-command flakes' \
-flake update`;
+const updateInputCmd = `nix --extra-experimental-features 'nix-command flakes' flake update nixpkgs`;
+const updateInputTokenCmd = `nix --extra-experimental-features 'nix-command flakes' --extra-access-tokens github.com=token flake update nixpkgs`;
+const lockfileMaintenanceCmd = `nix --extra-experimental-features 'nix-command flakes' flake update`;
 
 describe('modules/manager/nix/artifacts', () => {
   beforeEach(() => {
@@ -50,6 +43,10 @@ describe('modules/manager/nix/artifacts', () => {
     GlobalConfig.set(adminConfig);
     docker.resetPrefetchedImages();
     hostRules.find.mockReturnValue({ token: undefined });
+    hostRules.getAll.mockReturnValue([]);
+    fs.getSiblingFileName.mockImplementation(
+      (fileName, siblingName) => siblingName,
+    );
   });
 
   it('returns if no flake.lock found', async () => {
@@ -176,6 +173,7 @@ describe('modules/manager/nix/artifacts', () => {
 
   it('supports docker mode', async () => {
     GlobalConfig.set(dockerAdminConfig);
+    fs.readLocalFile.mockResolvedValueOnce('current flake.lock');
     const execSnapshots = mockExecAll();
     git.getRepoStatus.mockResolvedValue(
       partial<StatusResult>({
@@ -194,6 +192,7 @@ describe('modules/manager/nix/artifacts', () => {
     expect(res).toEqual([
       {
         file: {
+          contents: 'new flake.lock',
           path: 'flake.lock',
           type: 'addition',
         },
@@ -219,8 +218,44 @@ describe('modules/manager/nix/artifacts', () => {
     ]);
   });
 
+  it('writes newPackageFileContent', async () => {
+    fs.readLocalFile.mockResolvedValueOnce('old flake.lock');
+    const execSnapshots = mockExecAll();
+    git.getRepoStatus.mockResolvedValue(
+      partial<StatusResult>({
+        modified: ['flake.lock'],
+      }),
+    );
+    fs.readLocalFile.mockResolvedValueOnce('new flake.lock');
+
+    const newContent = 'updated flake.nix content';
+    const res = await updateArtifacts({
+      packageFileName: 'flake.nix',
+      updatedDeps: [{ depName: 'nixpkgs' }],
+      newPackageFileContent: newContent,
+      config,
+    });
+
+    expect(res).toEqual([
+      {
+        file: {
+          contents: 'new flake.lock',
+          path: 'flake.lock',
+          type: 'addition',
+        },
+      },
+    ]);
+
+    expect(fs.writeLocalFile).toHaveBeenCalledExactlyOnceWith(
+      'flake.nix',
+      newContent,
+    );
+    expect(execSnapshots).toMatchObject([{ cmd: updateInputCmd }]);
+  });
+
   it('supports install mode', async () => {
     GlobalConfig.set({ ...adminConfig, binarySource: 'install' });
+    fs.readLocalFile.mockResolvedValueOnce('current flake.lock');
     const execSnapshots = mockExecAll();
     git.getRepoStatus.mockResolvedValue(
       partial<StatusResult>({
@@ -239,6 +274,7 @@ describe('modules/manager/nix/artifacts', () => {
     expect(res).toEqual([
       {
         file: {
+          contents: 'new flake.lock',
           path: 'flake.lock',
           type: 'addition',
         },
@@ -303,6 +339,7 @@ describe('modules/manager/nix/artifacts', () => {
 
   it('uses nix from config', async () => {
     GlobalConfig.set(dockerAdminConfig);
+    fs.readLocalFile.mockResolvedValueOnce('current flake.lock');
     const execSnapshots = mockExecAll();
     git.getRepoStatus.mockResolvedValue(
       partial<StatusResult>({
@@ -324,6 +361,7 @@ describe('modules/manager/nix/artifacts', () => {
     expect(res).toEqual([
       {
         file: {
+          contents: 'new lock',
           path: 'flake.lock',
           type: 'addition',
         },
diff --git a/lib/modules/manager/nix/artifacts.ts b/lib/modules/manager/nix/artifacts.ts
index b16ab5494f4..1347dfa42a3 100644
--- a/lib/modules/manager/nix/artifacts.ts
+++ b/lib/modules/manager/nix/artifacts.ts
@@ -4,24 +4,35 @@ import { logger } from '../../../logger';
 import { findGithubToken } from '../../../util/check-token';
 import { exec } from '../../../util/exec';
 import type { ExecOptions } from '../../../util/exec/types';
-import { readLocalFile } from '../../../util/fs';
+import {
+  ensureCacheDir,
+  getSiblingFileName,
+  readLocalFile,
+  writeLocalFile,
+} from '../../../util/fs';
 import { getRepoStatus } from '../../../util/git';
+import { getGitEnvironmentVariables } from '../../../util/git/auth';
 import * as hostRules from '../../../util/host-rules';
-import { regEx } from '../../../util/regex';
 import type { UpdateArtifact, UpdateArtifactsResult } from '../types';
 
 export async function updateArtifacts({
   packageFileName,
   config,
   updatedDeps,
+  newPackageFileContent,
 }: UpdateArtifact): Promise<UpdateArtifactsResult[] | null> {
-  const lockFileName = packageFileName.replace(regEx(/\.nix$/), '.lock');
-  const existingLockFileContent = await readLocalFile(lockFileName, 'utf8');
+  const lockFileName = getSiblingFileName(packageFileName, 'flake.lock');
+  const existingLockFileContent = await readLocalFile(lockFileName);
+
+  logger.trace({ packageFileName, updatedDeps }, 'nix.updateArtifacts');
+
   if (!existingLockFileContent) {
     logger.debug('No flake.lock found');
     return null;
   }
 
+  await writeLocalFile(packageFileName, newPackageFileContent);
+
   let cmd = `nix --extra-experimental-features 'nix-command flakes' `;
 
   const token = findGithubToken(
@@ -47,6 +58,10 @@ export async function updateArtifacts({
   }
   const execOptions: ExecOptions = {
     cwdFile: packageFileName,
+    extraEnv: {
+      ...getGitEnvironmentVariables(),
+      NIX_CACHE_HOME: await ensureCacheDir('nix'),
+    },
     toolConstraints: [
       {
         toolName: 'nix',
diff --git a/lib/modules/manager/nix/extract.spec.ts b/lib/modules/manager/nix/extract.spec.ts
index 23521855009..b882d80e0a2 100644
--- a/lib/modules/manager/nix/extract.spec.ts
+++ b/lib/modules/manager/nix/extract.spec.ts
@@ -1,87 +1,69 @@
 import { codeBlock } from 'common-tags';
+import { ZodError } from 'zod';
 import { GitRefsDatasource } from '../../datasource/git-refs';
 import { id as nixpkgsVersioning } from '../../versioning/nixpkgs';
 import { extractPackageFile } from '.';
-import { fs } from '~test/util';
+import { fs, logger } from '~test/util';
 
 vi.mock('../../../util/fs');
 
 describe('modules/manager/nix/extract', () => {
-  it('returns null when no nixpkgs input exists', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    const flakeNix = codeBlock`{
-      inputs = {};
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile(flakeNix, 'flake.nix')).toBeNull();
+  beforeEach(() => {
+    fs.getSiblingFileName.mockImplementation(
+      (fileName, siblingName) => siblingName,
+    );
   });
 
-  it('does not include nixpkgs input with no explicit ref', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    const flakeNix = codeBlock`{
-      inputs = {
-        nixpkgs.url = "github:NixOS/nixpkgs";
-      };
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile(flakeNix, 'flake.nix')).toBeNull();
+  it('returns null when flake.lock file cannot be read', async () => {
+    fs.readLocalFile.mockResolvedValueOnce(null);
+    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
   });
 
-  it('includes nixpkgs input with only ref', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    const flakeNix = codeBlock`{
-      inputs = {
-        nixpkgs-lib.url = "https://github.com/NixOS/nixpkgs/archive/072a6db25e947df2f31aab9eccd0ab75d5b2da11.tar.gz";
-      };
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile(flakeNix, 'flake.nix')).toBeNull();
+  it('returns null when flake.lock cannot be parsed', async () => {
+    fs.readLocalFile.mockResolvedValueOnce('{ invalid json');
+    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      { flakeLockFile: 'flake.lock', error: expect.any(ZodError) },
+      'invalid flake.lock file',
+    );
   });
 
-  it('returns null when no inputs', async () => {
+  it('returns null when flake.lock is missing root node', async () => {
     const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
+      "nodes": {},
       "root": "root",
       "version": 7
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
     expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      { flakeLockFile: 'flake.lock' },
+      'flake.lock is missing "root" node',
+    );
   });
 
-  it('returns null when inputs are missing locked', async () => {
+  it('skips transitive dependencies', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
         "nixpkgs": {
+          "locked": {
+            "lastModified": 1743259260,
+            "narHash": "sha256-ArWLUgRm1tKHiqlhnymyVqi5kLNCK5ghvm06mfCl4QY=",
+            "owner": "NixOS",
+            "repo": "nixpkgs",
+            "rev": "eb0e0f21f15c559d2ac7633dc81d079d1caf5f5f",
+            "type": "github"
+          },
           "original": {
             "owner": "NixOS",
-            "ref": "nixos-unstable",
+            "ref": "nixpkgs-unstable",
             "repo": "nixpkgs",
             "type": "github"
           }
         },
         "root": {
           "inputs": {
-            "nixpkgs": "nixpkgs"
+            "disko": "disko"
           }
         }
       },
@@ -92,16 +74,14 @@ describe('modules/manager/nix/extract', () => {
     expect(await extractPackageFile('', 'flake.nix')).toBeNull();
   });
 
-  it('returns null when inputs are missing original', async () => {
+  it('returns null when inputs are missing locked', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
         "nixpkgs": {
-          "locked": {
-            "lastModified": 1720031269,
-            "narHash": "sha256-rwz8NJZV+387rnWpTYcXaRNvzUSnnF9aHONoJIYmiUQ=",
+          "original": {
             "owner": "NixOS",
+            "ref": "nixos-unstable",
             "repo": "nixpkgs",
-            "rev": "9f4128e00b0ae8ec65918efeba59db998750ead6",
             "type": "github"
           }
         },
@@ -116,9 +96,23 @@ describe('modules/manager/nix/extract', () => {
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
     expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      {
+        flakeLockFile: 'flake.lock',
+        flakeInput: {
+          original: {
+            owner: 'NixOS',
+            ref: 'nixos-unstable',
+            repo: 'nixpkgs',
+            type: 'github',
+          },
+        },
+      },
+      'input is missing locked, skipping',
+    );
   });
 
-  it('returns null when original inputs are from local path', async () => {
+  it('returns null when inputs are missing original', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
         "nixpkgs": {
@@ -129,12 +123,6 @@ describe('modules/manager/nix/extract', () => {
             "repo": "nixpkgs",
             "rev": "9f4128e00b0ae8ec65918efeba59db998750ead6",
             "type": "github"
-          },
-          "original": {
-            "owner": "NixOS",
-            "ref": "nixos-unstable",
-            "repo": "nixpkgs",
-            "type": "path"
           }
         },
         "root": {
@@ -148,6 +136,18 @@ describe('modules/manager/nix/extract', () => {
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
     expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      {
+        flakeLockFile: 'flake.lock',
+        flakeInput: {
+          locked: {
+            rev: '9f4128e00b0ae8ec65918efeba59db998750ead6',
+            type: 'github',
+          },
+        },
+      },
+      'input is missing original, skipping',
+    );
   });
 
   it('returns null when locked inputs are indirect', async () => {
@@ -180,6 +180,24 @@ describe('modules/manager/nix/extract', () => {
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
     expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      {
+        flakeLockFile: 'flake.lock',
+        flakeInput: {
+          locked: {
+            rev: '9f4128e00b0ae8ec65918efeba59db998750ead6',
+            type: 'indirect',
+          },
+          original: {
+            owner: 'NixOS',
+            ref: 'nixos-unstable',
+            repo: 'nixpkgs',
+            type: 'github',
+          },
+        },
+      },
+      'input is of type indirect, skipping',
+    );
   });
 
   it('returns null when locked inputs are from local path', async () => {
@@ -212,9 +230,27 @@ describe('modules/manager/nix/extract', () => {
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
     expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      {
+        flakeLockFile: 'flake.lock',
+        flakeInput: {
+          locked: {
+            rev: '9f4128e00b0ae8ec65918efeba59db998750ead6',
+            type: 'path',
+          },
+          original: {
+            owner: 'NixOS',
+            ref: 'nixos-unstable',
+            repo: 'nixpkgs',
+            type: 'github',
+          },
+        },
+      },
+      'input is of type path, skipping',
+    );
   });
 
-  it('returns nixpkgs input', async () => {
+  it('returns null when original inputs are from local path', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
         "nixpkgs": {
@@ -230,7 +266,7 @@ describe('modules/manager/nix/extract', () => {
             "owner": "NixOS",
             "ref": "nixos-unstable",
             "repo": "nixpkgs",
-            "type": "github"
+            "type": "path"
           }
         },
         "root": {
@@ -243,41 +279,45 @@ describe('modules/manager/nix/extract', () => {
       "version": 7
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toEqual({
-      deps: [
-        {
-          currentValue: 'nixos-unstable',
-          depName: 'nixpkgs',
-          datasource: GitRefsDatasource.id,
-          packageName: 'https://github.com/NixOS/nixpkgs',
-          versioning: nixpkgsVersioning,
-          lockedVersion: '9f4128e00b0ae8ec65918efeba59db998750ead6',
+    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      {
+        flakeLockFile: 'flake.lock',
+        flakeInput: {
+          locked: {
+            rev: '9f4128e00b0ae8ec65918efeba59db998750ead6',
+            type: 'github',
+          },
+          original: {
+            owner: 'NixOS',
+            ref: 'nixos-unstable',
+            repo: 'nixpkgs',
+            type: 'path',
+          },
         },
-      ],
-    });
+      },
+      'input is of type path, skipping',
+    );
   });
 
-  it('includes nixpkgs with no explicit ref', async () => {
+  it('ignores locked inputs not tracking a rev', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
-        "nixpkgs": {
+        "nixpkgs-lib": {
           "locked": {
-            "lastModified": 1728650607,
-            "narHash": "sha256-0lOnVTzRXzpk5uxbHLm3Ti3tyPAvirAIQDfwEUd8arg=",
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "rev": "612ee628421ba2c1abca4c99684862f76cb3b089",
-            "type": "github"
+            "lastModified": 1733096140,
+            "narHash": "sha256-1qRH7uAUsyQI7R1Uwl4T+XvdNv778H0Nb5njNrqvylY=",
+            "type": "tarball",
+            "url": "https://github.com/NixOS/nixpkgs/archive/5487e69da40cbd611ab2cadee0b4637225f7cfae.tar.gz"
           },
           "original": {
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "type": "github"
+            "type": "tarball",
+            "url": "https://github.com/NixOS/nixpkgs/archive/5487e69da40cbd611ab2cadee0b4637225f7cfae.tar.gz"
           }
         },
         "root": {
           "inputs": {
-            "nixpkgs": "nixpkgs"
+            "nixpkgs-lib": "nixpkgs-lib"
           }
         }
       },
@@ -285,57 +325,45 @@ describe('modules/manager/nix/extract', () => {
       "version": 7
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'nixpkgs',
-          packageName: 'https://github.com/NixOS/nixpkgs',
-          lockedVersion: '612ee628421ba2c1abca4c99684862f76cb3b089',
+    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+      {
+        flakeLockFile: 'flake.lock',
+        flakeInput: {
+          locked: {
+            type: 'tarball',
+            url: 'https://github.com/NixOS/nixpkgs/archive/5487e69da40cbd611ab2cadee0b4637225f7cfae.tar.gz',
+          },
+          original: {
+            type: 'tarball',
+            url: 'https://github.com/NixOS/nixpkgs/archive/5487e69da40cbd611ab2cadee0b4637225f7cfae.tar.gz',
+          },
         },
-      ],
-    });
+      },
+      'locked input is not tracking a rev, skipping',
+    );
   });
 
-  it('includes patchelf from HEAD', async () => {
+  it('matches dependency name to node name', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1672057183,
-            "narHash": "sha256-GN7/10DNNvs1FPj9tlZA2qgNdFuYKKuS3qlHTqAxasQ=",
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "rev": "b139e44d78c36c69bcbb825b20dbfa51e7738347",
-            "type": "github"
-          },
-          "original": {
-            "id": "nixpkgs",
-            "ref": "nixpkgs-unstable",
-            "type": "indirect"
-          }
-        },
-        "patchelf": {
-          "inputs": {
-            "nixpkgs": "nixpkgs"
-          },
+        "foobar": {
           "locked": {
-            "lastModified": 1718457448,
-            "narHash": "sha256-FSoxTcRZMGHNJh8dNtKOkcUtjhmhU6yQXcZZfUPLhQM=",
-            "ref": "refs/heads/master",
-            "rev": "a0f54334df36770b335c051e540ba40afcbf8378",
-            "revCount": 844,
-            "type": "git",
-            "url": "https://github.com/NixOS/patchelf.git"
+            "lastModified": 1733328505,
+            "narHash": "sha256-NeCCThCEP3eCl2l/+27kNNK7QrwZB1IJCrXfrbv5oqU=",
+            "rev": "ff81ac966bb2cae68946d5ed5fc4994f96d0ffec",
+            "revCount": 69,
+            "type": "tarball",
+            "url": "https://api.flakehub.com/f/pinned/edolstra/flake-compat/1.1.0/01948eb7-9cba-704f-bbf3-3fa956735b52/source.tar.gz"
           },
           "original": {
-            "type": "git",
-            "url": "https://github.com/NixOS/patchelf.git"
+            "type": "tarball",
+            "url": "https://flakehub.com/f/edolstra/flake-compat/1.tar.gz"
           }
         },
         "root": {
           "inputs": {
-            "patchelf": "patchelf"
+            "flake-compat": "foobar"
           }
         }
       },
@@ -343,982 +371,713 @@ describe('modules/manager/nix/extract', () => {
       "version": 7
     }`;
     fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
+    expect(await extractPackageFile('', 'flake.nix')).toEqual({
       deps: [
         {
-          datasource: 'git-refs',
-          depName: 'patchelf',
-          packageName: 'https://github.com/NixOS/patchelf.git',
-          lockedVersion: 'a0f54334df36770b335c051e540ba40afcbf8378',
+          currentDigest: 'ff81ac966bb2cae68946d5ed5fc4994f96d0ffec',
+          datasource: GitRefsDatasource.id,
+          depName: 'flake-compat',
+          packageName: 'https://flakehub.com/f/edolstra/flake-compat/1.tar.gz',
         },
       ],
     });
   });
 
-  it('includes ijq from sourcehut without a flake', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "ijq": {
-          "flake": false,
-          "locked": {
-            "lastModified": 1723569650,
-            "narHash": "sha256-Ho/sAhEUeSug52JALgjrKVUPCBe8+PovbJj/lniKxp8=",
-            "owner": "~gpanders",
-            "repo": "ijq",
-            "rev": "88f0d9ae98942bf49cba302c42b2a0f6e05f9b58",
-            "type": "sourcehut"
+  describe('Git inputs', () => {
+    it('supports input with ref', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          cachix.url = "git+https://github.com/cachix/cachix.git?ref=refs/tags/v1.7.2";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "cachix": {
+            "locked": {
+              "lastModified": 1709700175,
+              "narHash": "sha256-A0/6ZjLmT9qdYzKHmevnEIC7G+GiZ4UCr8v0poRPzds=",
+              "ref": "refs/tags/v1.7.2",
+              "rev": "be97b37989f11b724197b5f4c7ffd78f12c8c4bf",
+              "type": "git",
+              "url": "https://github.com/cachix/cachix.git"
+            },
+            "original": {
+              "ref": "refs/tags/v1.7.2",
+              "type": "git",
+              "url": "https://github.com/cachix/cachix.git"
+            }
           },
-          "original": {
-            "owner": "~gpanders",
-            "repo": "ijq",
-            "type": "sourcehut"
+          "root": {
+            "inputs": {
+              "cachix": "cachix"
+            }
           }
         },
-        "root": {
-          "inputs": {
-            "ijq": "ijq"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: 'be97b37989f11b724197b5f4c7ffd78f12c8c4bf',
+            currentValue: 'v1.7.2',
+            datasource: GitRefsDatasource.id,
+            depName: 'cachix',
+            packageName: 'https://github.com/cachix/cachix.git',
+            sourceUrl: 'https://github.com/cachix/cachix',
+          },
+        ],
+      });
+    });
+
+    it('supports input with rev', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          cachix.url = "git+https://github.com/cachix/cachix.git?rev=be97b37989f11b724197b5f4c7ffd78f12c8c4bf";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "cachix": {
+            "locked": {
+              "lastModified": 1709700175,
+              "narHash": "sha256-A0/6ZjLmT9qdYzKHmevnEIC7G+GiZ4UCr8v0poRPzds=",
+              "ref": "refs/heads/master",
+              "rev": "be97b37989f11b724197b5f4c7ffd78f12c8c4bf",
+              "type": "git",
+              "url": "https://github.com/cachix/cachix.git"
+            },
+            "original": {
+              "rev": "be97b37989f11b724197b5f4c7ffd78f12c8c4bf",
+              "type": "git",
+              "url": "https://github.com/cachix/cachix.git"
+            }
+          },
+          "root": {
+            "inputs": {
+              "cachix": "cachix"
+            }
           }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'ijq',
-          packageName: 'https://git.sr.ht/~gpanders/ijq',
-          lockedVersion: '88f0d9ae98942bf49cba302c42b2a0f6e05f9b58',
         },
-      ],
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: 'be97b37989f11b724197b5f4c7ffd78f12c8c4bf',
+            datasource: GitRefsDatasource.id,
+            depName: 'cachix',
+            packageName: 'https://github.com/cachix/cachix.git',
+            sourceUrl: 'https://github.com/cachix/cachix',
+          },
+        ],
+      });
     });
-  });
 
-  it('includes home-manager from gitlab', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "home-manager": {
-          "flake": false,
-          "locked": {
-            "lastModified": 1728650932,
-            "narHash": "sha256-mGKzqdsRyLnGNl6WjEr7+sghGgBtYHhJQ4mjpgRTCsU=",
-            "owner": "rycee",
-            "repo": "home-manager",
-            "rev": "65ae9c147349829d3df0222151f53f79821c5134",
-            "type": "gitlab"
+    it('supports input with ref and rev', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          cachix.url = "git+ssh://github.com/cachix/cachix.git?ref=refs/tags/v1.7.2&rev=be97b37989f11b724197b5f4c7ffd78f12c8c4bf";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "cachix": {
+            "locked": {
+              "lastModified": 1709700175,
+              "narHash": "sha256-A0/6ZjLmT9qdYzKHmevnEIC7G+GiZ4UCr8v0poRPzds=",
+              "ref": "refs/tags/v1.7.2",
+              "rev": "be97b37989f11b724197b5f4c7ffd78f12c8c4bf",
+              "type": "git",
+              "url": "ssh://git@github.com/cachix/cachix.git"
+            },
+            "original": {
+              "ref": "refs/tags/v1.7.2",
+              "rev": "be97b37989f11b724197b5f4c7ffd78f12c8c4bf",
+              "type": "git",
+              "url": "ssh://git@github.com/cachix/cachix.git"
+            }
           },
-          "original": {
-            "owner": "rycee",
-            "repo": "home-manager",
-            "type": "gitlab"
+          "root": {
+            "inputs": {
+              "cachix": "cachix"
+            }
           }
         },
-        "root": {
-          "inputs": {
-            "home-manager": "home-manager"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: 'be97b37989f11b724197b5f4c7ffd78f12c8c4bf',
+            currentValue: 'v1.7.2',
+            datasource: GitRefsDatasource.id,
+            depName: 'cachix',
+            packageName: 'git@github.com:cachix/cachix.git',
+            sourceUrl: 'https://github.com/cachix/cachix',
+          },
+        ],
+      });
+    });
+
+    it('supports locked input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          cachix.url = "git+https://github.com/cachix/cachix.git";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "cachix": {
+            "locked": {
+              "lastModified": 1709700175,
+              "narHash": "sha256-A0/6ZjLmT9qdYzKHmevnEIC7G+GiZ4UCr8v0poRPzds=",
+              "ref": "refs/heads/master",
+              "rev": "be97b37989f11b724197b5f4c7ffd78f12c8c4bf",
+              "type": "git",
+              "url": "https://github.com/cachix/cachix.git"
+            },
+            "original": {
+              "type": "git",
+              "url": "https://github.com/cachix/cachix.git"
+            }
+          },
+          "root": {
+            "inputs": {
+              "cachix": "cachix"
+            }
           }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'home-manager',
-          packageName: 'https://gitlab.com/rycee/home-manager',
-          lockedVersion: '65ae9c147349829d3df0222151f53f79821c5134',
         },
-      ],
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: 'be97b37989f11b724197b5f4c7ffd78f12c8c4bf',
+            datasource: GitRefsDatasource.id,
+            depName: 'cachix',
+            packageName: 'https://github.com/cachix/cachix.git',
+            sourceUrl: 'https://github.com/cachix/cachix',
+          },
+        ],
+      });
     });
-  });
 
-  it('test other version', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
-      "root": "root",
-      "version": 6
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+    it('supports shallow clone', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          nixpkgs-https.url = "git+https://github.com/NixOS/nixpkgs.git?rev=64334fda8d632bec7c80c9bef668ad9633a8dd64&depth=1";
+          nixpkgs-ssh.url = "git+ssh://git@github.com/NixOS/nixpkgs.git?rev=64334fda8d632bec7c80c9bef668ad9633a8dd64&depth=1";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "nixpkgs-https": {
+            "locked": {
+              "lastModified": 1758007619,
+              "narHash": "sha256-ADv63t4pEj5zhTAggwzyCbSpQosDtxKy0qg9cB9a1Eo=",
+              "ref": "refs/heads/master",
+              "rev": "64334fda8d632bec7c80c9bef668ad9633a8dd64",
+              "revCount": 862499,
+              "type": "git",
+              "url": "https://github.com/NixOS/nixpkgs.git?depth=1"
+            },
+            "original": {
+              "rev": "64334fda8d632bec7c80c9bef668ad9633a8dd64",
+              "type": "git",
+              "url": "https://github.com/NixOS/nixpkgs.git?depth=1"
+            }
+          },
+          "nixpkgs-ssh": {
+            "locked": {
+              "lastModified": 1758007619,
+              "narHash": "sha256-ADv63t4pEj5zhTAggwzyCbSpQosDtxKy0qg9cB9a1Eo=",
+              "rev": "64334fda8d632bec7c80c9bef668ad9633a8dd64",
+              "revCount": 862499,
+              "type": "git",
+              "url": "ssh://git@github.com/NixOS/nixpkgs.git?depth=1"
+            },
+            "original": {
+              "rev": "64334fda8d632bec7c80c9bef668ad9633a8dd64",
+              "type": "git",
+              "url": "ssh://git@github.com/NixOS/nixpkgs.git?depth=1"
+            }
+          },
+          "root": {
+            "inputs": {
+              "nixpkgs-https": "nixpkgs-https",
+              "nixpkgs-ssh": "nixpkgs-ssh"
+            }
+          }
+        },
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '64334fda8d632bec7c80c9bef668ad9633a8dd64',
+            datasource: GitRefsDatasource.id,
+            depName: 'nixpkgs-https',
+            packageName: 'https://github.com/NixOS/nixpkgs.git',
+            sourceUrl: 'https://github.com/NixOS/nixpkgs',
+          },
+          {
+            currentDigest: '64334fda8d632bec7c80c9bef668ad9633a8dd64',
+            datasource: GitRefsDatasource.id,
+            depName: 'nixpkgs-ssh',
+            packageName: 'git@github.com:NixOS/nixpkgs.git',
+            sourceUrl: 'https://github.com/NixOS/nixpkgs',
+          },
+        ],
+      });
+    });
   });
 
-  it('includes nixpkgs with ref and shallow arguments', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1728492678,
-            "narHash": "sha256-9UTxR8eukdg+XZeHgxW5hQA9fIKHsKCdOIUycTryeVw=",
-            "ref": "nixos-unstable",
-            "rev": "5633bcff0c6162b9e4b5f1264264611e950c8ec7",
-            "shallow": true,
-            "type": "git",
-            "url": "https://github.com/NixOS/nixpkgs"
+  describe('GitHub inputs', () => {
+    it('supports input with rev', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          flake-parts.url = "github:hercules-ci/flake-parts/4524271976b625a4a605beefd893f270620fd751";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "flake-parts": {
+            "locked": {
+              "lastModified": 1756770412,
+              "narHash": "sha256-+uWLQZccFHwqpGqr2Yt5VsW/PbeJVTn9Dk6SHWhNRPw=",
+              "owner": "hercules-ci",
+              "repo": "flake-parts",
+              "rev": "4524271976b625a4a605beefd893f270620fd751",
+              "type": "github"
+            },
+            "original": {
+              "owner": "hercules-ci",
+              "repo": "flake-parts",
+              "rev": "4524271976b625a4a605beefd893f270620fd751",
+              "type": "github"
+            }
           },
-          "original": {
-            "ref": "nixos-unstable",
-            "shallow": true,
-            "type": "git",
-            "url": "https://github.com/NixOS/nixpkgs"
+          "root": {
+            "inputs": {
+              "flake-parts": "flake-parts"
+            }
           }
         },
-        "root": {
-          "inputs": {
-            "nixpkgs": "nixpkgs"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '4524271976b625a4a605beefd893f270620fd751',
+            datasource: GitRefsDatasource.id,
+            depName: 'flake-parts',
+            packageName: 'https://github.com/hercules-ci/flake-parts',
+            sourceUrl: 'https://github.com/hercules-ci/flake-parts',
+          },
+        ],
+      });
+    });
+
+    it('supports locked input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          flake-parts.url = "github:hercules-ci/flake-parts";
+        };7
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "flake-parts": {
+            "locked": {
+              "lastModified": 1756770412,
+              "narHash": "sha256-+uWLQZccFHwqpGqr2Yt5VsW/PbeJVTn9Dk6SHWhNRPw=",
+              "owner": "hercules-ci",
+              "repo": "flake-parts",
+              "rev": "4524271976b625a4a605beefd893f270620fd751",
+              "type": "github"
+            },
+            "original": {
+              "owner": "hercules-ci",
+              "repo": "flake-parts",
+              "type": "github"
+            }
+          },
+          "root": {
+            "inputs": {
+              "flake-parts": "flake-parts"
+            }
           }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'nixpkgs',
-          packageName: 'https://github.com/NixOS/nixpkgs',
-          lockedVersion: '5633bcff0c6162b9e4b5f1264264611e950c8ec7',
         },
-      ],
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '4524271976b625a4a605beefd893f270620fd751',
+            datasource: GitRefsDatasource.id,
+            depName: 'flake-parts',
+            packageName: 'https://github.com/hercules-ci/flake-parts',
+            sourceUrl: 'https://github.com/hercules-ci/flake-parts',
+          },
+        ],
+      });
     });
-  });
 
-  it('includes nixpkgs but using indirect type that cannot be updated', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1728538411,
-            "narHash": "sha256-f0SBJz1eZ2yOuKUr5CA9BHULGXVSn6miBuUWdTyhUhU=",
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "rev": "b69de56fac8c2b6f8fd27f2eca01dcda8e0a4221",
-            "type": "github"
+    it('supports nixpkgs input with ref', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          flake-utils.url = "github:NixOS/nixpkgs/nixos-unstable";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "nixpkgs": {
+            "locked": {
+              "lastModified": 1720031269,
+              "narHash": "sha256-rwz8NJZV+387rnWpTYcXaRNvzUSnnF9aHONoJIYmiUQ=",
+              "owner": "NixOS",
+              "repo": "nixpkgs",
+              "rev": "9f4128e00b0ae8ec65918efeba59db998750ead6",
+              "type": "github"
+            },
+            "original": {
+              "owner": "NixOS",
+              "ref": "nixos-unstable",
+              "repo": "nixpkgs",
+              "type": "github"
+            }
           },
-          "original": {
-            "id": "nixpkgs",
-            "type": "indirect"
+          "root": {
+            "inputs": {
+              "nixpkgs": "nixpkgs"
+            }
           }
         },
-        "root": {
-          "inputs": {
-            "nixpkgs": "nixpkgs"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '9f4128e00b0ae8ec65918efeba59db998750ead6',
+            currentValue: 'nixos-unstable',
+            datasource: GitRefsDatasource.id,
+            depName: 'nixpkgs',
+            packageName: 'https://github.com/NixOS/nixpkgs',
+            sourceUrl: 'https://github.com/NixOS/nixpkgs',
+            versioning: nixpkgsVersioning,
+          },
+        ],
+      });
+    });
+
+    it('supports locked nixpkgs input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          flake-utils.url = "github:NixOS/nixpkgs";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "nixpkgs": {
+            "locked": {
+              "lastModified": 1728650607,
+              "narHash": "sha256-0lOnVTzRXzpk5uxbHLm3Ti3tyPAvirAIQDfwEUd8arg=",
+              "owner": "NixOS",
+              "repo": "nixpkgs",
+              "rev": "612ee628421ba2c1abca4c99684862f76cb3b089",
+              "type": "github"
+            },
+            "original": {
+              "owner": "NixOS",
+              "repo": "nixpkgs",
+              "type": "github"
+            }
+          },
+          "root": {
+            "inputs": {
+              "nixpkgs": "nixpkgs"
+            }
           }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+        },
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '612ee628421ba2c1abca4c99684862f76cb3b089',
+            datasource: GitRefsDatasource.id,
+            depName: 'nixpkgs',
+            packageName: 'https://github.com/NixOS/nixpkgs',
+            sourceUrl: 'https://github.com/NixOS/nixpkgs',
+            versioning: 'nixpkgs',
+          },
+        ],
+      });
+    });
   });
 
-  it('includes nixpkgs but using indirect type and path locked type that cannot be updated', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1687274257,
-            "narHash": "sha256-TutzPriQcZ8FghDhEolnHcYU2oHIG5XWF+/SUBNnAOE=",
-            "path": "/nix/store/22qgs3skscd9bmrxv9xv4q5d4wwm5ppx-source",
-            "rev": "2c9ecd1f0400076a4d6b2193ad468ff0a7e7fdc5",
-            "type": "path"
+  describe('GitHub Enterprise inputs', () => {
+    it('supports ...', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          nixpkgs-extra-pkgs.url = "github:my-org/nixpkgs-extra-pkgs?host=github.corp.example.com";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "nixpkgs-extra-pkgs": {
+            "locked": {
+              "host": "github.corp.example.com",
+              "lastModified": 1728666512,
+              "narHash": "sha256-p+l16Zzyl2DXG695yks6KQP7NkjsnEksu5GBvtL1QYg=",
+              "owner": "my-org",
+              "repo": "nixpkgs-extra-pkgs",
+              "rev": "6bf2706348447df6f8b86b1c3e54f87b0afda84f",
+              "type": "github"
+            },
+            "original": {
+              "host": "github.corp.example.com",
+              "owner": "my-org",
+              "repo": "nixpkgs-extra-pkgs",
+              "type": "github"
+            }
           },
-          "original": {
-            "id": "nixpkgs",
-            "type": "indirect"
+          "root": {
+            "inputs": {
+              "nixpkgs-extra-pkgs": "nixpkgs-extra-pkgs"
+            }
           }
         },
-        "root": {
-          "inputs": {
-            "nixpkgs": "nixpkgs"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '6bf2706348447df6f8b86b1c3e54f87b0afda84f',
+            datasource: GitRefsDatasource.id,
+            depName: 'nixpkgs-extra-pkgs',
+            packageName:
+              'https://github.corp.example.com/my-org/nixpkgs-extra-pkgs',
+            sourceUrl:
+              'https://github.corp.example.com/my-org/nixpkgs-extra-pkgs',
+          },
+        ],
+      });
+    });
   });
 
-  it('includes flake from GitHub Enterprise', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "flake-utils": {
-          "inputs": {
-            "systems": "systems"
+  describe('GitLab inputs', () => {
+    it('supports locked input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          home-manager.url = "gitlab:rycee/home-manager";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "home-manager": {
+            "locked": {
+              "lastModified": 1757385184,
+              "narHash": "sha256-LCxtQn9ajvOgGRbQIRUJgfP7clMGGvV1SDW1HcSb0zk=",
+              "owner": "rycee",
+              "repo": "home-manager",
+              "rev": "26993d87fd0d3b14f7667b74ad82235f120d986e",
+              "type": "gitlab"
+            },
+            "original": {
+              "owner": "rycee",
+              "repo": "home-manager",
+              "type": "gitlab"
+            }
           },
-          "locked": {
-            "lastModified": 1726560853,
-            "narHash": "sha256-X6rJYSESBVr3hBoH0WbKE5KvhPU5bloyZ2L4K60/fPQ=",
-            "owner": "numtide",
-            "repo": "flake-utils",
-            "rev": "c1dfcf08411b08f6b8615f7d8971a2bfa81d5e8a",
-            "type": "github"
+          "root": {
+            "inputs": {
+              "home-manager": "home-manager"
+            }
+          }
+        },
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '26993d87fd0d3b14f7667b74ad82235f120d986e',
+            datasource: GitRefsDatasource.id,
+            depName: 'home-manager',
+            packageName: 'https://gitlab.com/rycee/home-manager',
+            sourceUrl: 'https://gitlab.com/rycee/home-manager',
           },
-          "original": {
-            "owner": "numtide",
-            "repo": "flake-utils",
-            "type": "github"
-          }
-        },
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1728492678,
-            "narHash": "sha256-9UTxR8eukdg+XZeHgxW5hQA9fIKHsKCdOIUycTryeVw=",
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "rev": "5633bcff0c6162b9e4b5f1264264611e950c8ec7",
-            "type": "github"
-          },
-          "original": {
-            "owner": "NixOS",
-            "ref": "nixos-unstable",
-            "repo": "nixpkgs",
-            "type": "github"
-          }
-        },
-        "nixpkgs-extra-pkgs": {
-          "inputs": {
-            "flake-utils": "flake-utils",
-            "nixpkgs": "nixpkgs"
-          },
-          "locked": {
-            "host": "github.corp.example.com",
-            "lastModified": 1728666512,
-            "narHash": "sha256-p+l16Zzyl2DXG695yks6KQP7NkjsnEksu5GBvtL1QYg=",
-            "owner": "my-org",
-            "repo": "nixpkgs-extra-pkgs",
-            "rev": "6bf2706348447df6f8b86b1c3e54f87b0afda84f",
-            "type": "github"
-          },
-          "original": {
-            "host": "github.corp.example.com",
-            "owner": "my-org",
-            "repo": "nixpkgs-extra-pkgs",
-            "type": "github"
-          }
-        },
-        "root": {
-          "inputs": {
-            "nixpkgs-extra-pkgs": "nixpkgs-extra-pkgs"
-          }
-        },
-        "systems": {
-          "locked": {
-            "lastModified": 1681028828,
-            "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
-            "owner": "nix-systems",
-            "repo": "default",
-            "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
-            "type": "github"
-          },
-          "original": {
-            "owner": "nix-systems",
-            "repo": "default",
-            "type": "github"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'nixpkgs-extra-pkgs',
-          packageName:
-            'https://github.corp.example.com/my-org/nixpkgs-extra-pkgs',
-          lockedVersion: '6bf2706348447df6f8b86b1c3e54f87b0afda84f',
-        },
-      ],
-    });
-  });
-
-  it('includes flake with tarball type', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "data-mesher": {
-          "inputs": {
-            "flake-parts": "flake-parts",
-            "nixpkgs": "nixpkgs",
-            "treefmt-nix": "treefmt-nix"
-          },
-          "locked": {
-            "lastModified": 1727355895,
-            "narHash": "sha256-grZIaLgk5GgoDuTt49RTCLBh458H4YJdIAU4B3onXRw=",
-            "rev": "c7e39452affcc0f89e023091524e38b3aaf109e9",
-            "type": "tarball",
-            "url": "https://git.clan.lol/api/v1/repos/clan/data-mesher/archive/c7e39452affcc0f89e023091524e38b3aaf109e9.tar.gz"
-          },
-          "original": {
-            "type": "tarball",
-            "url": "https://git.clan.lol/clan/data-mesher/archive/main.tar.gz"
-          }
-        },
-        "flake-parts": {
-          "inputs": {
-            "nixpkgs-lib": [
-              "data-mesher",
-              "nixpkgs"
-            ]
-          },
-          "locked": {
-            "lastModified": 1726153070,
-            "narHash": "sha256-HO4zgY0ekfwO5bX0QH/3kJ/h4KvUDFZg8YpkNwIbg1U=",
-            "owner": "hercules-ci",
-            "repo": "flake-parts",
-            "rev": "bcef6817a8b2aa20a5a6dbb19b43e63c5bf8619a",
-            "type": "github"
-          },
-          "original": {
-            "owner": "hercules-ci",
-            "repo": "flake-parts",
-            "type": "github"
-          }
-        },
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1726871744,
-            "narHash": "sha256-V5LpfdHyQkUF7RfOaDPrZDP+oqz88lTJrMT1+stXNwo=",
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "rev": "a1d92660c6b3b7c26fb883500a80ea9d33321be2",
-            "type": "github"
-          },
-          "original": {
-            "owner": "NixOS",
-            "ref": "nixpkgs-unstable",
-            "repo": "nixpkgs",
-            "type": "github"
-          }
-        },
-        "root": {
-          "inputs": {
-            "data-mesher": "data-mesher"
-          }
-        },
-        "treefmt-nix": {
-          "inputs": {
-            "nixpkgs": [
-              "data-mesher",
-              "nixpkgs"
-            ]
-          },
-          "locked": {
-            "lastModified": 1726734507,
-            "narHash": "sha256-VUH5O5AcOSxb0uL/m34dDkxFKP6WLQ6y4I1B4+N3L2w=",
-            "owner": "numtide",
-            "repo": "treefmt-nix",
-            "rev": "ee41a466c2255a3abe6bc50fc6be927cdee57a9f",
-            "type": "github"
-          },
-          "original": {
-            "owner": "numtide",
-            "repo": "treefmt-nix",
-            "type": "github"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'data-mesher',
-          packageName: 'https://git.clan.lol/clan/data-mesher',
-          lockedVersion: 'c7e39452affcc0f89e023091524e38b3aaf109e9',
-        },
-      ],
-    });
-  });
-
-  it('uri decode gitlab subgroup', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "subgroup-project": {
-          "locked": {
-            "lastModified": 1739792862,
-            "narHash": "sha256-n0MrSIZZknq2OqOYgNS0iMp2yVRekpBFGhrhsT7aXGg=",
-            "owner": "group%2Fsub-group",
-            "repo": "subgroup-project",
-            "rev": "24b560624f154c9e962d146217b2a964faaf2055",
-            "type": "gitlab"
-          },
-          "original": {
-            "owner": "group%2Fsub-group",
-            "repo": "subgroup-project",
-            "type": "gitlab"
-          }
-        },
-        "root": {
-          "inputs": {
-            "subgroup-project": "subgroup-project"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'subgroup-project',
-          packageName: 'https://gitlab.com/group/sub-group/subgroup-project',
-          lockedVersion: '24b560624f154c9e962d146217b2a964faaf2055',
-        },
-      ],
-    });
-  });
-
-  it('includes flake with only tarball type', async () => {
-    const flakeLock = codeBlock`{
-    "nodes": {
-      "nixpkgs-lib": {
-        "locked": {
-          "lastModified": 1738452942,
-          "narHash": "sha256-vJzFZGaCpnmo7I6i416HaBLpC+hvcURh/BQwROcGIp8=",
-          "type": "tarball",
-          "url": "https://github.com/NixOS/nixpkgs/archive/072a6db25e947df2f31aab9eccd0ab75d5b2da11.tar.gz"
-        },
-        "original": {
-          "type": "tarball",
-          "url": "https://github.com/NixOS/nixpkgs/archive/072a6db25e947df2f31aab9eccd0ab75d5b2da11.tar.gz"
-        }
-      },
-      "root": {
-        "inputs": {
-          "nixpkgs-lib": "nixpkgs-lib"
-        }
-      }
-    },
-    "root": "root",
-    "version": 7
-  }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
-  });
-
-  it('includes flake with nixpkgs-lib as tarball type', async () => {
-    const flakeLock = codeBlock`{
-    "nodes": {
-      "flake-parts": {
-        "inputs": {
-          "nixpkgs-lib": "nixpkgs-lib"
-        },
-        "locked": {
-          "lastModified": 1733312601,
-          "narHash": "sha256-4pDvzqnegAfRkPwO3wmwBhVi/Sye1mzps0zHWYnP88c=",
-          "owner": "hercules-ci",
-          "repo": "flake-parts",
-          "rev": "205b12d8b7cd4802fbcb8e8ef6a0f1408781a4f9",
-          "type": "github"
-        },
-        "original": {
-          "owner": "hercules-ci",
-          "repo": "flake-parts",
-          "type": "github"
-        }
-      },
-      "nixpkgs": {
-        "locked": {
-          "lastModified": 1734649271,
-          "narHash": "sha256-4EVBRhOjMDuGtMaofAIqzJbg4Ql7Ai0PSeuVZTHjyKQ=",
-          "owner": "nixos",
-          "repo": "nixpkgs",
-          "rev": "d70bd19e0a38ad4790d3913bf08fcbfc9eeca507",
-          "type": "github"
-        },
-        "original": {
-          "owner": "nixos",
-          "ref": "nixos-unstable",
-          "repo": "nixpkgs",
-          "type": "github"
-        }
-      },
-      "nixpkgs-lib": {
-        "locked": {
-          "lastModified": 1733096140,
-          "narHash": "sha256-1qRH7uAUsyQI7R1Uwl4T+XvdNv778H0Nb5njNrqvylY=",
-          "type": "tarball",
-          "url": "https://github.com/NixOS/nixpkgs/archive/5487e69da40cbd611ab2cadee0b4637225f7cfae.tar.gz"
-        },
-        "original": {
-          "type": "tarball",
-          "url": "https://github.com/NixOS/nixpkgs/archive/5487e69da40cbd611ab2cadee0b4637225f7cfae.tar.gz"
-        }
-      },
-      "root": {
-        "inputs": {
-          "flake-parts": "flake-parts",
-          "nixpkgs": "nixpkgs"
-        }
-      }
-    },
-    "root": "root",
-    "version": 7
-  }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'flake-parts',
-          packageName: 'https://github.com/hercules-ci/flake-parts',
-          lockedVersion: '205b12d8b7cd4802fbcb8e8ef6a0f1408781a4f9',
-        },
-        {
-          currentValue: 'nixos-unstable',
-          datasource: 'git-refs',
-          depName: 'nixpkgs',
-          packageName: 'https://github.com/NixOS/nixpkgs',
-          lockedVersion: 'd70bd19e0a38ad4790d3913bf08fcbfc9eeca507',
-        },
-      ],
-    });
-  });
-
-  it('includes flake with nixpkgs channel as tarball type', async () => {
-    const flakeLock = codeBlock`{
-    "nodes": {
-      "nixpkgs": {
-        "locked": {
-          "lastModified": 1756904031,
-          "narHash": "sha256-V29Bu1nR6Ayt+uUhf/6L43DSxb66BQ+8E2wH1GHa5IA=",
-          "rev": "0e6684e6c5755325f801bda1751a8a4038145d7d",
-          "type": "tarball",
-          "url": "https://releases.nixos.org/nixos/25.05/nixos-25.05.809350.0e6684e6c575/nixexprs.tar.xz"
-        },
-        "original": {
-          "type": "tarball",
-          "url": "https://channels.nixos.org/nixpkgs-unstable/nixexprs.tar.xz"
-        }
-      },
-      "root": {
-        "inputs": {
-          "nixpkgs": "nixpkgs"
-        }
-      }
-    },
-    "root": "root",
-    "version": 7
-  }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          currentValue: 'nixpkgs-unstable',
-          datasource: 'git-refs',
-          depName: 'nixpkgs',
-          packageName: 'https://github.com/NixOS/nixpkgs',
-          lockedVersion: '0e6684e6c5755325f801bda1751a8a4038145d7d',
-          versioning: 'nixpkgs',
-        },
-      ],
-    });
-  });
-
-  it('finds currentDigest correctly when input sha is pinned', async () => {
-    const flakeNix = codeBlock`{
-      inputs = {
-        disko.url = "github:nix-community/disko/76c0a6dba345490508f36c1aa3c7ba5b6b460989";
-      };
-    }`;
-    const flakeLock = codeBlock`{
-    "nodes": {
-      "disko": {
-        "locked": {
-          "lastModified": 1744145203,
-          "narHash": "sha256-I2oILRiJ6G+BOSjY+0dGrTPe080L3pbKpc+gCV3Nmyk=",
-          "owner": "nix-community",
-          "repo": "disko",
-          "rev": "76c0a6dba345490508f36c1aa3c7ba5b6b460989",
-          "type": "github"
-        },
-        "original": {
-          "owner": "nix-community",
-          "repo": "disko",
-          "rev": "76c0a6dba345490508f36c1aa3c7ba5b6b460989",
-          "type": "github"
-        }
-      },
-      "root": {
-        "inputs": {
-          "disko": "disko"
-        }
-      }
-    },
-    "root": "root",
-    "version": 7
-  }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile(flakeNix, 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          currentDigest: '76c0a6dba345490508f36c1aa3c7ba5b6b460989',
-          datasource: 'git-refs',
-          depName: 'disko',
-          packageName: 'https://github.com/nix-community/disko',
-        },
-      ],
-    });
-  });
-
-  it('does not duplicate nixpkgs dependency', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1756904031,
-            "narHash": "sha256-V29Bu1nR6Ayt+uUhf/6L43DSxb66BQ+8E2wH1GHa5IA=",
-            "rev": "0e6684e6c5755325f801bda1751a8a4038145d7d",
-            "type": "tarball",
-            "url": "https://releases.nixos.org/nixos/25.05/nixos-25.05.809350.0e6684e6c575/nixexprs.tar.xz"
-          },
-          "original": {
-            "type": "tarball",
-            "url": "https://channels.nixos.org/nixpkgs-unstable/nixexprs.tar.xz"
-          }
-        },
-        "root": {
-          "inputs": {
-            "nixpkgs": "nixpkgs"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    const flakeNix = codeBlock`{
-      inputs = {
-        nixpkgs.url = "github:nixos/nixpkgs/nixos-21.11";
-      };
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
-      deps: [
-        {
-          currentValue: 'nixpkgs-unstable',
-          datasource: 'git-refs',
-          depName: 'nixpkgs',
-          packageName: 'https://github.com/NixOS/nixpkgs',
-          lockedVersion: '0e6684e6c5755325f801bda1751a8a4038145d7d',
-          versioning: 'nixpkgs',
-        },
-      ],
+        ],
+      });
     });
   });
 
-  it('returns null when flake.lock file cannot be read', async () => {
-    fs.readLocalFile.mockResolvedValueOnce(null);
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
-  });
-
-  it('returns null when flake.nix file cannot be read', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    fs.readLocalFile.mockResolvedValueOnce(null);
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
-  });
-
-  it('returns null when flake.lock has invalid JSON', async () => {
-    fs.readLocalFile.mockResolvedValueOnce('{ invalid json');
-    expect(await extractPackageFile('', 'flake.nix')).toBeNull();
-  });
-
-  it('returns deps when no root inputs but deps exist', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "root": {}
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-
-    const result = await extractPackageFile('', 'flake.nix');
-    expect(result).toBeNull();
-  });
-
-  it('handles currentDigest replacement when config provided', async () => {
-    const flakeNix = codeBlock`{
-      inputs = {
-        disko.url = "github:nix-community/disko/newdigest123";
-      };
-    }`;
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "disko": {
-          "locked": {
-            "lastModified": 1744145203,
-            "narHash": "sha256-I2oILRiJ6G+BOSjY+0dGrTPe080L3pbKpc+gCV3Nmyk=",
-            "owner": "nix-community",
-            "repo": "disko",
-            "rev": "76c0a6dba345490508f36c1aa3c7ba5b6b460989",
-            "type": "github"
+  describe('SourceHut inputs', () => {
+    it('supports locked input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          firefox-addons.url = "sourcehut:~rycee/nur-expressions?dir=pkgs/firefox-addons";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "firefox-addons": {
+            "locked": {
+              "dir": "pkgs/firefox-addons",
+              "lastModified": 1755702597,
+              "narHash": "sha256-Z56emoVLFBhX/WcoXWiXienLX8jHrBExyqQjNd5/r0k=",
+              "owner": "~rycee",
+              "repo": "nur-expressions",
+              "rev": "2dcb371b407ba4009e27a8e8adf88e6f93d40bfb",
+              "type": "sourcehut"
+            },
+            "original": {
+              "dir": "pkgs/firefox-addons",
+              "owner": "~rycee",
+              "repo": "nur-expressions",
+              "type": "sourcehut"
+            }
           },
-          "original": {
-            "owner": "nix-community",
-            "repo": "disko",
-            "rev": "olddigest123",
-            "type": "github"
+          "root": {
+            "inputs": {
+              "firefox-addons": "firefox-addons"
+            }
           }
         },
-        "root": {
-          "inputs": {
-            "disko": "disko"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    const config = {
-      currentDigest: 'olddigest123',
-      newDigest: 'newdigest123',
-    };
-
-    const result = await extractPackageFile(flakeNix, 'flake.nix', config);
-    expect(result?.deps[0]).toMatchObject({
-      currentDigest: 'newdigest123',
-      depName: 'disko',
-      packageName: 'https://github.com/nix-community/disko',
-    });
-  });
-
-  it('includes nixpkgs with ref when original has rev', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "nixpkgs": {
-          "locked": {
-            "lastModified": 1720031269,
-            "narHash": "sha256-rwz8NJZV+387rnWpTYcXaRNvzUSnnF9aHONoJIYmiUQ=",
-            "owner": "NixOS",
-            "repo": "nixpkgs",
-            "rev": "9f4128e00b0ae8ec65918efeba59db998750ead6",
-            "type": "github"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '2dcb371b407ba4009e27a8e8adf88e6f93d40bfb',
+            datasource: GitRefsDatasource.id,
+            depName: 'firefox-addons',
+            packageName: 'https://git.sr.ht/~rycee/nur-expressions',
+            sourceUrl: 'https://git.sr.ht/~rycee/nur-expressions',
           },
-          "original": {
-            "owner": "NixOS",
-            "ref": "nixos-unstable",
-            "repo": "nixpkgs",
-            "rev": "specific-commit-hash",
-            "type": "github"
-          }
-        },
-        "root": {
-          "inputs": {
-            "nixpkgs": "nixpkgs"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          currentValue: 'nixos-unstable',
-          currentDigest: 'specific-commit-hash',
-          depName: 'nixpkgs',
-          packageName: 'https://github.com/NixOS/nixpkgs',
-        },
-      ],
+        ],
+      });
     });
   });
 
-  it('includes github flake with ref when original has rev', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "flake-utils": {
-          "locked": {
-            "lastModified": 1726560853,
-            "narHash": "sha256-X6rJYSESBVr3hBoH0WbKE5KvhPU5bloyZ2L4K60/fPQ=",
-            "owner": "numtide",
-            "repo": "flake-utils",
-            "rev": "c1dfcf08411b08f6b8615f7d8971a2bfa81d5e8a",
-            "type": "github"
+  describe('Tarball inputs', () => {
+    it('supports locked input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          lix = {
+            url = "https://git.lix.systems/lix-project/lix/archive/main.tar.gz";
+            flake = false;
+          };
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "lix": {
+            "flake": false,
+            "locked": {
+              "lastModified": 1756426754,
+              "narHash": "sha256-EVJDo/KjdGtvJKelVPoL92TsPNrqnOJUnaLTIqP+F0o=",
+              "rev": "f4bdddf0fdaabc68546cf561c5343b83d95d2466",
+              "type": "tarball",
+              "url": "https://git.lix.systems/api/v1/repos/lix-project/lix/archive/f4bdddf0fdaabc68546cf561c5343b83d95d2466.tar.gz"
+            },
+            "original": {
+              "type": "tarball",
+              "url": "https://git.lix.systems/lix-project/lix/archive/main.tar.gz"
+            }
           },
-          "original": {
-            "owner": "numtide",
-            "repo": "flake-utils",
-            "ref": "main",
-            "rev": "specific-commit-hash",
-            "type": "github"
-          }
-        },
-        "root": {
-          "inputs": {
-            "flake-utils": "flake-utils"
+          "root": {
+            "inputs": {
+              "lix": "lix"
+            }
           }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          currentValue: 'main',
-          currentDigest: 'specific-commit-hash',
-          depName: 'flake-utils',
-          packageName: 'https://github.com/numtide/flake-utils',
         },
-      ],
-    });
-  });
-
-  it('includes gitlab flake with custom host', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "custom-project": {
-          "locked": {
-            "lastModified": 1728650932,
-            "narHash": "sha256-mGKzqdsRyLnGNl6WjEr7+sghGgBtYHhJQ4mjpgRTCsU=",
-            "owner": "group",
-            "repo": "project",
-            "rev": "65ae9c147349829d3df0222151f53f79821c5134",
-            "type": "gitlab",
-            "host": "gitlab.example.com"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: 'f4bdddf0fdaabc68546cf561c5343b83d95d2466',
+            datasource: GitRefsDatasource.id,
+            depName: 'lix',
+            packageName: 'https://git.lix.systems/lix-project/lix',
           },
-          "original": {
-            "owner": "group",
-            "repo": "project",
-            "type": "gitlab",
-            "host": "gitlab.example.com"
-          }
-        },
-        "root": {
-          "inputs": {
-            "custom-project": "custom-project"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'custom-project',
-          packageName: 'https://gitlab.example.com/group/project',
-          lockedVersion: '65ae9c147349829d3df0222151f53f79821c5134',
-        },
-      ],
+        ],
+      });
     });
-  });
 
-  it('includes sourcehut flake with custom host', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "custom-project": {
-          "locked": {
-            "lastModified": 1723569650,
-            "narHash": "sha256-Ho/sAhEUeSug52JALgjrKVUPCBe8+PovbJj/lniKxp8=",
-            "owner": "~user",
-            "repo": "project",
-            "rev": "88f0d9ae98942bf49cba302c42b2a0f6e05f9b58",
-            "type": "sourcehut",
-            "host": "git.custom.org"
+    it('supports locked nixpkgs input', async () => {
+      const flakeNix = codeBlock`{
+        inputs = {
+          nixpkgs.url = "https://channels.nixos.org/nixpkgs-unstable/nixexprs.tar.xz";
+        };
+      }`;
+      const flakeLock = codeBlock`{
+        "nodes": {
+          "nixpkgs": {
+            "locked": {
+              "lastModified": 1756904031,
+              "narHash": "sha256-V29Bu1nR6Ayt+uUhf/6L43DSxb66BQ+8E2wH1GHa5IA=",
+              "rev": "0e6684e6c5755325f801bda1751a8a4038145d7d",
+              "type": "tarball",
+              "url": "https://releases.nixos.org/nixos/25.05/nixos-25.05.809350.0e6684e6c575/nixexprs.tar.xz"
+            },
+            "original": {
+              "type": "tarball",
+              "url": "https://channels.nixos.org/nixpkgs-unstable/nixexprs.tar.xz"
+            }
           },
-          "original": {
-            "owner": "~user",
-            "repo": "project",
-            "type": "sourcehut",
-            "host": "git.custom.org"
-          }
-        },
-        "root": {
-          "inputs": {
-            "custom-project": "custom-project"
+          "root": {
+            "inputs": {
+              "nixpkgs": "nixpkgs"
+            }
           }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          datasource: 'git-refs',
-          depName: 'custom-project',
-          packageName: 'https://git.custom.org/~user/project',
-          lockedVersion: '88f0d9ae98942bf49cba302c42b2a0f6e05f9b58',
         },
-      ],
-    });
-  });
-
-  it('includes tarball flake with ref when original has rev', async () => {
-    const flakeLock = codeBlock`{
-      "nodes": {
-        "data-mesher": {
-          "locked": {
-            "lastModified": 1727355895,
-            "narHash": "sha256-grZIaLgk5GgoDuTt49RTCLBh458H4YJdIAU4B3onXRw=",
-            "rev": "c7e39452affcc0f89e023091524e38b3aaf109e9",
-            "type": "tarball",
-            "url": "https://git.clan.lol/api/v1/repos/clan/data-mesher/archive/c7e39452affcc0f89e023091524e38b3aaf109e9.tar.gz"
+        "root": "root",
+        "version": 7
+      }`;
+      fs.readLocalFile.mockResolvedValueOnce(flakeLock);
+      expect(await extractPackageFile(flakeNix, 'flake.nix')).toEqual({
+        deps: [
+          {
+            currentDigest: '0e6684e6c5755325f801bda1751a8a4038145d7d',
+            currentValue: 'nixpkgs-unstable',
+            datasource: GitRefsDatasource.id,
+            depName: 'nixpkgs',
+            packageName: 'https://github.com/NixOS/nixpkgs',
+            versioning: nixpkgsVersioning,
           },
-          "original": {
-            "type": "tarball",
-            "url": "https://git.clan.lol/clan/data-mesher/archive/main.tar.gz",
-            "ref": "main",
-            "rev": "specific-commit-hash"
-          }
-        },
-        "root": {
-          "inputs": {
-            "data-mesher": "data-mesher"
-          }
-        }
-      },
-      "root": "root",
-      "version": 7
-    }`;
-    fs.readLocalFile.mockResolvedValueOnce(flakeLock);
-    expect(await extractPackageFile('', 'flake.nix')).toMatchObject({
-      deps: [
-        {
-          currentValue: 'main',
-          currentDigest: 'specific-commit-hash',
-          datasource: 'git-refs',
-          depName: 'data-mesher',
-          packageName: 'https://git.clan.lol/clan/data-mesher',
-        },
-      ],
+        ],
+      });
     });
   });
 
-  it('handles unknown flake lock type', async () => {
+  it('ignores unknown inputs types', async () => {
     const flakeLock = codeBlock`{
       "nodes": {
         "unknown-flake": {
diff --git a/lib/modules/manager/nix/extract.ts b/lib/modules/manager/nix/extract.ts
index 6404e030a8e..5184501c223 100644
--- a/lib/modules/manager/nix/extract.ts
+++ b/lib/modules/manager/nix/extract.ts
@@ -1,20 +1,16 @@
 import { logger } from '../../../logger';
 import { getSiblingFileName, readLocalFile } from '../../../util/fs';
+import { getHttpUrl, parseGitUrl } from '../../../util/git/url';
 import { regEx } from '../../../util/regex';
 import { GitRefsDatasource } from '../../datasource/git-refs';
-import { id as gitRefVersioning } from '../../versioning/git';
 import { id as nixpkgsVersioning } from '../../versioning/nixpkgs';
-import type {
-  ExtractConfig,
-  PackageDependency,
-  PackageFileContent,
-} from '../types';
+import type { PackageDependency, PackageFileContent } from '../types';
 import { NixFlakeLock } from './schema';
 
 // as documented upstream
 // https://github.com/NixOS/nix/blob/master/doc/manual/source/protocols/tarball-fetcher.md#gitea-and-forgejo-support
 const lockableHTTPTarballProtocol = regEx(
-  '^https://(?<domain>[^/]+)/(?<owner>[^/]+)/(?<repo>[^/]+)/archive/(?<rev>.+).tar.gz$',
+  '^https://(?<domain>[^/]+)/(?<owner>[^/]+)/(?<repo>[^/]+)/archive/(?<rev>.+)\\.tar\\.gz$',
 );
 
 const lockableChannelOriginalUrl = regEx(
@@ -24,55 +20,53 @@ const lockableChannelOriginalUrl = regEx(
 export async function extractPackageFile(
   content: string,
   packageFile: string,
-  config?: ExtractConfig,
 ): Promise<PackageFileContent | null> {
   const flakeLockFile = getSiblingFileName(packageFile, 'flake.lock');
   const flakeLockContents = await readLocalFile(flakeLockFile, 'utf8');
-
-  logger.trace(`nix.extractPackageFile(${flakeLockFile})`);
-
   const deps: PackageDependency[] = [];
 
+  logger.trace({ flakeLockFile }, 'nix.extractPackageFile()');
+
   const flakeLockParsed = NixFlakeLock.safeParse(flakeLockContents);
   if (!flakeLockParsed.success) {
     logger.debug(
       { flakeLockFile, error: flakeLockParsed.error },
-      `invalid flake.lock file`,
+      'invalid flake.lock file',
     );
     return null;
   }
 
   const flakeLock = flakeLockParsed.data;
-  const rootInputs = flakeLock.nodes.root.inputs;
-
-  if (!rootInputs) {
-    logger.debug(
-      { flakeLockFile, error: flakeLockParsed.error },
-      `flake.lock is missing "root" node`,
-    );
+  const rootInputs = new Map(
+    Object.entries(flakeLock.nodes.root?.inputs ?? {}).map(([key, value]) => [
+      value,
+      key,
+    ]),
+  );
+
+  if (!rootInputs.size) {
+    logger.debug({ flakeLockFile }, 'flake.lock is missing "root" node');
     return null;
   }
 
-  for (const [depName, flakeInput] of Object.entries(flakeLock.nodes)) {
+  for (const [node, flakeInput] of Object.entries(flakeLock.nodes)) {
     // the root input is a magic string for the entrypoint and only references other flake inputs
-    if (depName === 'root') {
+    if (node === 'root') {
       continue;
     }
 
-    // skip all locked and transitivie nodes as they cannot be updated by regular means
-    if (!(depName in rootInputs)) {
+    // skip all locked and transitive nodes as they cannot be updated by regular means
+    if (!rootInputs.has(node)) {
       continue;
     }
 
-    // flakeLocked example: { rev: '56a49ffef2908dad1e9a8adef1f18802bc760962', type: 'github' }
     const flakeLocked = flakeInput.locked;
-    // flakeOriginal example: { owner: 'NuschtOS', repo: 'search', type: 'github' }
     const flakeOriginal = flakeInput.original;
 
     if (flakeLocked === undefined) {
       logger.debug(
         { flakeLockFile, flakeInput },
-        `input is missing locked, skipping`,
+        'input is missing locked, skipping',
       );
       continue;
     }
@@ -80,7 +74,7 @@ export async function extractPackageFile(
     if (flakeOriginal === undefined) {
       logger.debug(
         { flakeLockFile, flakeInput },
-        `input is missing original, skipping`,
+        'input is missing original, skipping',
       );
       continue;
     }
@@ -89,7 +83,7 @@ export async function extractPackageFile(
     if (flakeOriginal.type === 'indirect' || flakeLocked.type === 'indirect') {
       logger.debug(
         { flakeLockFile, flakeInput },
-        `input is type indirect, skipping`,
+        'input is of type indirect, skipping',
       );
       continue;
     }
@@ -98,7 +92,7 @@ export async function extractPackageFile(
     if (flakeOriginal.type === 'path' || flakeLocked.type === 'path') {
       logger.debug(
         { flakeLockFile, flakeInput },
-        `input is type path, skipping`,
+        'input is of type path, skipping',
       );
       continue;
     }
@@ -107,45 +101,24 @@ export async function extractPackageFile(
     if (flakeLocked.rev === undefined) {
       logger.debug(
         { flakeLockFile, flakeInput },
-        `locked input is not tracking a rev, skipping`,
+        'locked input is not tracking a rev, skipping',
       );
       continue;
     }
 
-    // if there's a new digest, set the corresponding digest in the lockfile so confirmations pass
-    const currentDigest = config?.currentDigest;
-    const newDigest = config?.newDigest;
-    if (
-      currentDigest &&
-      newDigest &&
-      flakeOriginal.rev &&
-      flakeOriginal.rev === currentDigest && // currentDigest is the old digest
-      content.includes(newDigest) // flake.nix contains the new digest
-    ) {
-      logger.debug(
-        { flakeLockFile, flakeInput },
-        `overriding rev ${flakeOriginal.rev} with new digest ${newDigest}`,
-      );
-      flakeOriginal.rev = newDigest;
-    }
-
     const dep: PackageDependency = {
-      depName,
+      depName: rootInputs.get(node),
       datasource: GitRefsDatasource.id,
-      versioning: gitRefVersioning,
     };
 
-    // if rev is set, the flake contains a digest and can be updated directly
-    // otherwise set lockedVersion so it is updated during lock file maintenance
-    if (flakeOriginal.rev) {
-      dep.currentValue = flakeOriginal.ref;
-      dep.currentDigest = flakeOriginal.rev;
-      dep.replaceString = flakeOriginal.rev;
-    } else {
-      dep.lockedVersion = flakeLocked.rev;
-    }
+    dep.currentValue = flakeOriginal.ref?.replace(/^refs\/(heads|tags)\//, '');
+    dep.currentDigest = flakeLocked.rev;
 
     switch (flakeLocked.type) {
+      case 'git':
+        dep.packageName = parseGitUrl(flakeOriginal.url!).toString();
+        break;
+
       case 'github':
         // set to nixpkgs if it is a nixpkgs reference
         if (
@@ -153,7 +126,6 @@ export async function extractPackageFile(
           flakeOriginal.repo?.toLowerCase() === 'nixpkgs'
         ) {
           dep.packageName = 'https://github.com/NixOS/nixpkgs';
-          dep.currentValue = flakeOriginal.ref;
           dep.versioning = nixpkgsVersioning;
           break;
         }
@@ -165,10 +137,6 @@ export async function extractPackageFile(
         dep.packageName = `https://${flakeOriginal.host ?? 'gitlab.com'}/${decodeURIComponent(flakeOriginal.owner!)}/${flakeOriginal.repo}`;
         break;
 
-      case 'git':
-        dep.packageName = flakeOriginal.url;
-        break;
-
       case 'sourcehut':
         dep.packageName = `https://${flakeOriginal.host ?? 'git.sr.ht'}/${flakeOriginal.owner}/${flakeOriginal.repo}`;
         break;
@@ -195,12 +163,16 @@ export async function extractPackageFile(
         break;
     }
 
+    if (flakeLocked.type !== 'tarball') {
+      dep.sourceUrl = getHttpUrl(dep.packageName!).replace(/\.git$/, '');
+    }
+
     deps.push(dep);
   }
 
-  if (deps.length) {
-    return { deps };
+  if (deps.length === 0) {
+    return null;
   }
 
-  return null;
+  return { deps };
 }
diff --git a/lib/modules/manager/nix/index.ts b/lib/modules/manager/nix/index.ts
index 57976429ef9..ca58e35aa6c 100644
--- a/lib/modules/manager/nix/index.ts
+++ b/lib/modules/manager/nix/index.ts
@@ -1,18 +1,14 @@
 import { GitRefsDatasource } from '../../datasource/git-refs';
 
-export { extractPackageFile } from './extract';
 export { updateArtifacts } from './artifacts';
-export { getRangeStrategy } from './range';
+export { extractPackageFile } from './extract';
+export { updateDependency } from './update';
 
+export const supportedDatasources = [GitRefsDatasource.id];
 export const supportsLockFileMaintenance = true;
-
 export const url = 'https://nix.dev';
 
 export const defaultConfig = {
   managerFilePatterns: ['/(^|/)flake\\.nix$/'],
-  commitMessageTopic: 'nix',
-  commitMessageExtra: 'to {{newValue}}',
   enabled: false,
 };
-
-export const supportedDatasources = [GitRefsDatasource.id];
diff --git a/lib/modules/manager/nix/range.spec.ts b/lib/modules/manager/nix/range.spec.ts
deleted file mode 100644
index 3c43e9f6e45..00000000000
--- a/lib/modules/manager/nix/range.spec.ts
+++ /dev/null
@@ -1,17 +0,0 @@
-import type { RangeConfig } from '../types';
-import { getRangeStrategy } from '.';
-
-describe('modules/manager/nix/range', () => {
-  it('returns replace if currentValue not null', () => {
-    const config: RangeConfig = {
-      rangeStrategy: 'auto',
-      currentValue: '1.0.0',
-    };
-    expect(getRangeStrategy(config)).toBe('replace');
-  });
-
-  it('defaults to update-lockfile', () => {
-    const config: RangeConfig = { rangeStrategy: 'auto', depType: 'require' };
-    expect(getRangeStrategy(config)).toBe('update-lockfile');
-  });
-});
diff --git a/lib/modules/manager/nix/update.spec.ts b/lib/modules/manager/nix/update.spec.ts
new file mode 100644
index 00000000000..475dc9e94c8
--- /dev/null
+++ b/lib/modules/manager/nix/update.spec.ts
@@ -0,0 +1,449 @@
+import { codeBlock } from 'common-tags';
+import { updateDependency } from './update';
+import { logger } from '~test/util';
+
+describe('modules/manager/nix/update', () => {
+  describe('updateDependency', () => {
+    it('returns null if no depName', () => {
+      const fileContent = 'test';
+      const result = updateDependency({
+        fileContent,
+        upgrade: {
+          currentValue: '1.0.0',
+          newValue: '2.0.0',
+        },
+      });
+      expect(result).toBeNull();
+      expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+        'No depName provided',
+      );
+    });
+
+    it('returns null if dependency not found', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            nixpkgs.url = "github:NixOS/nixpkgs";
+          };
+        }
+      `;
+      const result = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'nonexistent',
+          currentValue: '1.0.0',
+          newValue: '2.0.0',
+        },
+      });
+      expect(result).toBeNull();
+      expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+        'Could not find URL for dependency nonexistent',
+      );
+    });
+
+    it('returns null if dependency has invalid URL', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            nixpkgs.url = "derp";
+          };
+        }
+      `;
+      const result = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'nixpkgs',
+        },
+      });
+      expect(result).toBeNull();
+      expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+        'Could not parse URL for dependency nixpkgs: derp',
+      );
+    });
+
+    describe('GitHub sources', () => {
+      it('updates branch', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.05";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'nixpkgs',
+            currentValue: '24.05',
+            newValue: '25.05',
+          },
+        });
+        expect(result).toContain('nixos-25.05');
+        expect(result).not.toContain('nixos-24.05');
+      });
+
+      it('updates commit', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              nixpkgs.url = "github:NixOS/nixpkgs/af51545ec9a44eadf3fe3547610a5cdd882bc34e";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'nixpkgs',
+            currentDigest: 'af51545ec9a44eadf3fe3547610a5cdd882bc34e',
+            newDigest: '11cb3517b3af6af300dd6c055aeda73c9bf52c48',
+          },
+        });
+        expect(result).toContain('11cb3517b3af6af300dd6c055aeda73c9bf52c48');
+        expect(result).not.toContain(
+          'af51545ec9a44eadf3fe3547610a5cdd882bc34e',
+        );
+      });
+
+      it('updates branch ref', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              nixpkgs.url = "github:NixOS/nixpkgs?ref=refs/heads/nixos-24.05";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'nixpkgs',
+            currentValue: '24.05',
+            newValue: '25.05',
+          },
+        });
+        expect(result).toContain('ref=refs/heads/nixos-25.05');
+        expect(result).not.toContain('ref=refs/heads/nixos-24.05');
+      });
+
+      it('updates tag ref', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              nixpkgs.url = "github:NixOS/nixpkgs?ref=refs/tags/24.05";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'nixpkgs',
+            currentValue: '24.05',
+            newValue: '25.05',
+          },
+        });
+        expect(result).toContain('ref=refs/tags/25.05');
+        expect(result).not.toContain('ref=refs/tags/24.05');
+      });
+
+      it('updates rev', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              nixpkgs.url = "github:NixOS/nixpkgs?rev=af51545ec9a44eadf3fe3547610a5cdd882bc34e";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'nixpkgs',
+            currentDigest: 'af51545ec9a44eadf3fe3547610a5cdd882bc34e',
+            newDigest: '11cb3517b3af6af300dd6c055aeda73c9bf52c48',
+          },
+        });
+        expect(result).toContain(
+          'rev=11cb3517b3af6af300dd6c055aeda73c9bf52c48',
+        );
+        expect(result).not.toContain(
+          'rev=af51545ec9a44eadf3fe3547610a5cdd882bc34e',
+        );
+      });
+    });
+
+    describe('Git sources', () => {
+      it('updates branch ref with refs/heads/ prefix', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              mypackage.url = "git+ssh://git@example.com/org/repo?ref=refs/heads/release-1.0";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'mypackage',
+            currentValue: '1.0',
+            newValue: '2.0',
+          },
+        });
+        expect(result).toContain('ref=refs/heads/release-2.0');
+        expect(result).not.toContain('ref=refs/heads/release-1.0');
+      });
+
+      it('updates branch ref without refs/heads/ prefix', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              mypackage.url = "git+ssh://git@example.com/org/repo?ref=release-1.0";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'mypackage',
+            currentValue: '1.0',
+            newValue: '2.0',
+          },
+        });
+        expect(result).toContain('ref=release-2.0');
+        expect(result).not.toContain('ref=release-1.0');
+      });
+
+      it('updates tag ref', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              mypackage.url = "git+ssh://git@example.com/org/repo?ref=refs/tags/1.0.0";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'mypackage',
+            currentValue: '1.0.0',
+            newValue: '2.0.0',
+          },
+        });
+        expect(result).toContain('ref=refs/tags/2.0.0');
+        expect(result).not.toContain('ref=refs/tags/1.0.0');
+      });
+
+      it('updates rev', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              mypackage.url = "git+ssh://git@example.com/org/repo?rev=0da084a03fa90c38c859208c38fae6bbfd7b9144";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'mypackage',
+            currentDigest: '0da084a03fa90c38c859208c38fae6bbfd7b9144',
+            newDigest: '7b6b5d6a5ac69143671c30570f9fa5eaa6318e89',
+          },
+        });
+        expect(result).toContain(
+          'rev=7b6b5d6a5ac69143671c30570f9fa5eaa6318e89',
+        );
+        expect(result).not.toContain(
+          'rev=0da084a03fa90c38c859208c38fae6bbfd7b9144',
+        );
+      });
+
+      it('updates ref and rev', () => {
+        const fileContent = codeBlock`
+          {
+            inputs = {
+              foo-bar.url = "git+ssh://git@example.com/foo/bar?ref=refs/tags/2.8.0&rev=73d65dcf7d7af76346b084c775e4df9697372a45";
+            };
+          }
+        `;
+        const result = updateDependency({
+          fileContent,
+          upgrade: {
+            depName: 'foo-bar',
+            currentValue: '2.8.0',
+            newValue: '2.23.0',
+            currentDigest: '73d65dcf7d7af76346b084c775e4df9697372a45',
+            newDigest: '2d503a1f6dd58a771f0ee3ded286f2f11c49a6f2',
+          },
+        });
+        expect(result).toContain('ref=refs/tags/2.23.0');
+        expect(result).toContain(
+          'rev=2d503a1f6dd58a771f0ee3ded286f2f11c49a6f2',
+        );
+        expect(result).not.toContain('ref=refs/tags/2.8.0');
+        expect(result).not.toContain(
+          'rev=73d65dcf7d7af76346b084c775e4df9697372a45',
+        );
+      });
+    });
+
+    it('returns null when no changes are needed', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            mypackage.url = "git+ssh://git@example.com/org/repo?ref=refs/tags/1.0.0";
+          };
+        }
+      `;
+      const result = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'mypackage',
+          currentValue: '1.0.0',
+          newValue: '1.0.0',
+        },
+      });
+      expect(result).toBeNull();
+      expect(logger.logger.trace).toHaveBeenNthCalledWith(
+        3,
+        {
+          depName: 'mypackage',
+          url: 'git+ssh://git@example.com/org/repo?ref=refs/tags/1.0.0',
+        },
+        'No changes made to URL',
+      );
+    });
+
+    it('updates dependencies with attribute set syntax', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            cachix-github-ref-tag = { url = "github:cachix/cachix?ref=refs/tags/v1.7.2"; };
+            cachix-githttps-ref-tag = {
+              url = "git+https://github.com/cachix/cachix.git?ref=refs/tags/v1.7.2";
+            };
+          };
+        }
+      `;
+      const result1 = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'cachix-github-ref-tag',
+          currentValue: 'v1.7.2',
+          newValue: 'v1.8.0',
+        },
+      });
+      expect(result1).toContain(
+        'cachix-github-ref-tag = { url = "github:cachix/cachix?ref=refs/tags/v1.8.0"',
+      );
+
+      const result2 = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'cachix-githttps-ref-tag',
+          currentValue: 'v1.7.2',
+          newValue: 'v1.8.0',
+        },
+      });
+      expect(result2).toContain(
+        'url = "git+https://github.com/cachix/cachix.git?ref=refs/tags/v1.8.0"',
+      );
+    });
+
+    it('returns unchanged content for digest-only updates', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            nixpkgs-tar.url = "https://nixos.org/channels/nixpkgs-unstable/nixexprs.tar.xz";
+          };
+        }
+      `;
+      const result = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'nixpkgs-tar',
+          currentValue: 'nixpkgs-unstable',
+          newValue: 'nixpkgs-unstable',
+          currentDigest: '58dcbf1ec551914c3756c267b8b9c8c86baa1b2f',
+          newDigest: '88cef159e47c0dc56f151593e044453a39a6e547',
+        },
+      });
+      expect(result).toBe(fileContent);
+      expect(logger.logger.debug).toHaveBeenCalledExactlyOnceWith(
+        {
+          depName: 'nixpkgs-tar',
+          currentDigest: '58dcbf1ec551914c3756c267b8b9c8c86baa1b2f',
+          newDigest: '88cef159e47c0dc56f151593e044453a39a6e547',
+          currentValue: 'nixpkgs-unstable',
+        },
+        'Digest-only update detected, returning unchanged content for lock file update',
+      );
+    });
+
+    it('updates only the specific matched occurrence when multiple exist', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            nixpkgs-branch.url = "github:NixOS/nixpkgs/nixos-24.05";
+            nixpkgs-ref.url = "github:NixOS/nixpkgs?ref=nixos-24.05";
+          };
+        }
+      `;
+
+      const result1 = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'nixpkgs-branch',
+          currentValue: 'nixos-24.05',
+          newValue: 'nixos-24.11',
+        },
+      });
+      expect(result1).toContain(
+        'nixpkgs-branch.url = "github:NixOS/nixpkgs/nixos-24.11"',
+      );
+      expect(result1).toContain(
+        'nixpkgs-ref.url = "github:NixOS/nixpkgs?ref=nixos-24.05"',
+      );
+
+      const result2 = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'nixpkgs-ref',
+          currentValue: 'nixos-24.05',
+          newValue: 'nixos-24.11',
+        },
+      });
+      expect(result2).toContain(
+        'nixpkgs-branch.url = "github:NixOS/nixpkgs/nixos-24.05"',
+      );
+      expect(result2).toContain(
+        'nixpkgs-ref.url = "github:NixOS/nixpkgs?ref=nixos-24.11"',
+      );
+    });
+
+    it('returns null for digest-only updates when digests are the same', () => {
+      const fileContent = codeBlock`
+        {
+          inputs = {
+            nixpkgs-tar.url = "https://nixos.org/channels/nixpkgs-unstable/nixexprs.tar.xz";
+          };
+        }
+      `;
+      const result = updateDependency({
+        fileContent,
+        upgrade: {
+          depName: 'nixpkgs-tar',
+          currentValue: 'nixpkgs-unstable',
+          newValue: 'nixpkgs-unstable',
+          currentDigest: '58dcbf1ec551914c3756c267b8b9c8c86baa1b2f',
+          newDigest: '58dcbf1ec551914c3756c267b8b9c8c86baa1b2f',
+        },
+      });
+      expect(result).toBeNull();
+      expect(logger.logger.trace).toHaveBeenNthCalledWith(
+        3,
+        {
+          depName: 'nixpkgs-tar',
+          url: 'https://nixos.org/channels/nixpkgs-unstable/nixexprs.tar.xz',
+        },
+        'No changes made to URL',
+      );
+    });
+  });
+});
diff --git a/lib/modules/manager/nix/update.ts b/lib/modules/manager/nix/update.ts
new file mode 100644
index 00000000000..c31494aa97c
--- /dev/null
+++ b/lib/modules/manager/nix/update.ts
@@ -0,0 +1,150 @@
+import { logger } from '../../../logger';
+import { escapeRegExp, regEx } from '../../../util/regex';
+import { parseUrl } from '../../../util/url';
+import type { UpdateDependencyConfig } from '../types';
+
+export function updateDependency({
+  fileContent,
+  upgrade,
+}: UpdateDependencyConfig): string | null {
+  const { depName, currentValue, newValue, currentDigest, newDigest } = upgrade;
+  logger.trace({ depName, currentValue, newValue }, 'nix.updateDependency()');
+
+  if (!depName) {
+    logger.debug('No depName provided');
+    return null;
+  }
+
+  // Find the input line for this dependency
+  // Support both direct assignment (`depName.url = "..."`) and attribute set syntax (`depName = { url = "..."; }`)
+  const directPattern = regEx(
+    `^\\s*${escapeRegExp(depName)}\\.url\\s*=\\s*"([^"]+)"`,
+    'gm',
+  );
+  const attrSetPattern = regEx(
+    `^\\s*${escapeRegExp(depName)}\\s*=\\s*\\{[^}]*url\\s*=\\s*"([^"]+)"`,
+    'gms',
+  );
+  const match =
+    directPattern.exec(fileContent) ?? attrSetPattern.exec(fileContent);
+
+  if (!match) {
+    logger.debug(`Could not find URL for dependency ${depName}`);
+    return null;
+  }
+
+  const matchedString = match[0];
+  const oldUrl = match[1];
+  const parsedUrl = parseUrl(oldUrl);
+  let newUrl = oldUrl;
+
+  if (!parsedUrl) {
+    logger.debug(`Could not parse URL for dependency ${depName}: ${oldUrl}`);
+    return null;
+  }
+
+  logger.trace({ depName, parsedUrl }, 'Parsed URL for update');
+
+  // Special handling for `github:` protocol URLs where the URL object doesn't properly serialize changes to non-standard protocols
+  if (parsedUrl.protocol === 'github:') {
+    // Handle version updates
+    if (
+      currentValue &&
+      newValue &&
+      currentValue !== newValue &&
+      oldUrl.includes(currentValue)
+    ) {
+      newUrl = newUrl.replace(currentValue, newValue);
+    }
+
+    // Handle digest updates
+    if (
+      currentDigest &&
+      newDigest &&
+      currentDigest !== newDigest &&
+      newUrl.includes(currentDigest)
+    ) {
+      newUrl = newUrl.replace(currentDigest, newDigest);
+    }
+  } else {
+    let urlModified = false;
+
+    // Handle ref updates (version updates)
+    if (currentValue && newValue && currentValue !== newValue) {
+      const refParam = parsedUrl.searchParams.get('ref');
+
+      if (refParam) {
+        const refMatch = /^refs\/(tags|heads)\/(.+)$/.exec(refParam);
+        if (refMatch) {
+          const updatedRef = `refs/${refMatch[1]}/${refMatch[2].replace(currentValue, newValue)}`;
+          parsedUrl.searchParams.set('ref', updatedRef);
+          urlModified = true;
+        } else if (refParam.includes(currentValue)) {
+          const updatedRef = refParam.replace(currentValue, newValue);
+          parsedUrl.searchParams.set('ref', updatedRef);
+          urlModified = true;
+        }
+      }
+    }
+
+    // Handle rev updates (digest updates)
+    if (currentDigest && newDigest && currentDigest !== newDigest) {
+      const revParam = parsedUrl.searchParams.get('rev');
+
+      if (revParam && revParam === currentDigest) {
+        parsedUrl.searchParams.set('rev', newDigest);
+        urlModified = true;
+      }
+    }
+
+    // Convert back to string, preserving the unencoded forward slashes in query params
+    if (urlModified) {
+      newUrl = parsedUrl.toString();
+
+      // URL constructor encodes forward slashes in query params but Nix URLs expect them unencoded
+      const queryStart = newUrl.indexOf('?');
+      if (queryStart !== -1) {
+        newUrl =
+          newUrl.substring(0, queryStart) +
+          newUrl.substring(queryStart).replace(/%2F/g, '/');
+      }
+    }
+  }
+
+  if (newUrl === oldUrl) {
+    // Check if this is a digest-only update (version doesn't change, only digest changes)
+    if (
+      currentValue === newValue &&
+      currentDigest &&
+      newDigest &&
+      currentDigest !== newDigest
+    ) {
+      logger.debug(
+        { depName, currentDigest, newDigest, currentValue },
+        'Digest-only update detected, returning unchanged content for lock file update',
+      );
+
+      // Return the unchanged content - the lock file will be updated via artifacts
+      return fileContent;
+    }
+
+    logger.trace({ depName, url: oldUrl }, 'No changes made to URL');
+    return null;
+  }
+
+  // Replace the old URL with the new URL at the specific match position
+  const replacedMatch = matchedString.replace(oldUrl, newUrl);
+  const updatedContent =
+    fileContent.substring(0, match.index) +
+    replacedMatch +
+    fileContent.substring(match.index + matchedString.length);
+
+  /* v8 ignore next 4 -- should never happen */
+  if (updatedContent === fileContent) {
+    logger.debug({ depName }, 'Failed to update file content');
+    return null;
+  }
+
+  logger.debug({ depName, oldUrl, newUrl }, 'Successfully updated Nix flake');
+  return updatedContent;
+}
diff --git a/lib/workers/repository/update/branch/get-updated.spec.ts b/lib/workers/repository/update/branch/get-updated.spec.ts
index f7779b91f8b..3671d8e8162 100644
--- a/lib/workers/repository/update/branch/get-updated.spec.ts
+++ b/lib/workers/repository/update/branch/get-updated.spec.ts
@@ -7,6 +7,7 @@ import * as _composer from '../../../../modules/manager/composer';
 import * as _gitSubmodules from '../../../../modules/manager/git-submodules';
 import * as _gomod from '../../../../modules/manager/gomod';
 import * as _helmv3 from '../../../../modules/manager/helmv3';
+import * as _nix from '../../../../modules/manager/nix';
 import * as _npm from '../../../../modules/manager/npm';
 import * as _pep621 from '../../../../modules/manager/pep621';
 import * as _pipCompile from '../../../../modules/manager/pip-compile';
@@ -26,6 +27,7 @@ const composer = vi.mocked(_composer);
 const gitSubmodules = vi.mocked(_gitSubmodules);
 const gomod = vi.mocked(_gomod);
 const helmv3 = vi.mocked(_helmv3);
+const nix = vi.mocked(_nix);
 const npm = vi.mocked(_npm);
 const batectWrapper = vi.mocked(_batectWrapper);
 const autoReplace = vi.mocked(_autoReplace);
@@ -39,6 +41,7 @@ vi.mock('../../../../modules/manager/helmv3');
 vi.mock('../../../../modules/manager/npm');
 vi.mock('../../../../modules/manager/git-submodules');
 vi.mock('../../../../modules/manager/gomod', () => mockDeep());
+vi.mock('../../../../modules/manager/nix');
 vi.mock('../../../../modules/manager/batect-wrapper');
 vi.mock('../../../../modules/manager/pep621');
 vi.mock('../../../../modules/manager/pip-compile');
@@ -508,6 +511,73 @@ describe('workers/repository/update/branch/get-updated', () => {
       });
     });
 
+    it('handles nix digest-only updates without including unchanged files in commit', async () => {
+      const fileContent = 'existing content';
+      config.upgrades.push({
+        packageFile: 'flake.nix',
+        manager: 'nix',
+        datasource: GitRefsDatasource.id,
+        branchName: 'renovate/nixpkgs-tar-digest',
+        depName: 'nixpkgs-tar',
+        currentValue: 'nixpkgs-unstable',
+        newValue: 'nixpkgs-unstable',
+        currentDigest: '58dcbf1ec551914c3756c267b8b9c8c86baa1b2f',
+        newDigest: '88cef159e47c0dc56f151593e044453a39a6e547',
+        updateType: 'digest',
+      } satisfies BranchUpgradeConfig);
+
+      // For digest-only updates, Nix returns unchanged content
+      nix.updateDependency.mockResolvedValueOnce(fileContent);
+      nix.updateArtifacts.mockResolvedValueOnce([
+        {
+          file: {
+            type: 'addition',
+            path: 'flake.lock',
+            contents: 'updated lock file content',
+          },
+        },
+      ]);
+
+      const res = await getUpdatedPackageFiles(config);
+
+      // The unchanged flake.nix should not be in updatedPackageFiles but the lock file should be updated via artifacts
+      expect(res.updatedPackageFiles).toEqual([]);
+      expect(res.updatedArtifacts).toEqual([
+        {
+          type: 'addition',
+          path: 'flake.lock',
+          contents: 'updated lock file content',
+        },
+      ]);
+    });
+
+    it('handles nix non-digest updates normally', async () => {
+      const updatedContent = 'updated content';
+      config.upgrades.push({
+        packageFile: 'flake.nix',
+        manager: 'nix',
+        datasource: GitRefsDatasource.id,
+        branchName: 'renovate/nixpkgs-branch',
+        depName: 'nixpkgs-branch',
+        currentValue: 'nixos-24.05',
+        newValue: 'nixos-24.11',
+        updateType: 'minor',
+      } satisfies BranchUpgradeConfig);
+
+      nix.updateDependency.mockResolvedValueOnce(updatedContent);
+
+      const res = await getUpdatedPackageFiles(config);
+      expect(res).toMatchObject({
+        updatedPackageFiles: [
+          {
+            contents: updatedContent,
+            path: 'flake.nix',
+            type: 'addition',
+          },
+        ],
+      });
+    });
+
     /*
      * The pip-compile manager uses lock files, the regex manager does not.
      * Verify pip-compile updates the lock files even if the same dependency
diff --git a/lib/workers/repository/update/branch/get-updated.ts b/lib/workers/repository/update/branch/get-updated.ts
index db64ad21426..ee7cc62fdc1 100644
--- a/lib/workers/repository/update/branch/get-updated.ts
+++ b/lib/workers/repository/update/branch/get-updated.ts
@@ -103,6 +103,7 @@ export async function getUpdatedPackageFiles(
   );
   let updatedFileContents: Record<string, string> = {};
   const nonUpdatedFileContents: Record<string, string> = {};
+  const artifactUpdateNeeded: Record<string, string> = {};
   const managerPackageFiles: Record<string, Set<string>> = {};
   const packageFileUpdatedDeps: Record<string, PackageDependency[]> = {};
   const lockFileMaintenanceFiles: string[] = [];
@@ -305,6 +306,19 @@ export async function getUpdatedPackageFiles(
           updatedFileContents[packageFile] = newContent;
           delete nonUpdatedFileContents[packageFile];
         }
+        if (
+          manager === 'nix' &&
+          upgrade.currentValue === upgrade.newValue &&
+          upgrade.currentDigest &&
+          upgrade.newDigest &&
+          upgrade.currentDigest !== upgrade.newDigest
+        ) {
+          logger.debug(
+            { packageFile, depName },
+            'Nix digest-only update - tracking for artifact update',
+          );
+          artifactUpdateNeeded[packageFile] = newContent;
+        }
       }
     }
   }
@@ -315,18 +329,27 @@ export async function getUpdatedPackageFiles(
     path: name,
     contents: updatedFileContents[name],
   }));
+  // For artifact processing, include both updated files and files needing artifact updates
+  const filesForArtifacts: FileAddition[] = [
+    ...updatedPackageFiles,
+    ...Object.keys(artifactUpdateNeeded).map((name) => ({
+      type: 'addition' as const,
+      path: name,
+      contents: artifactUpdateNeeded[name],
+    })),
+  ];
   const updatedArtifacts: FileChange[] = [];
   const artifactErrors: ArtifactError[] = [];
   const artifactNotices: ArtifactNotice[] = [];
-  if (isNonEmptyArray(updatedPackageFiles)) {
+  if (isNonEmptyArray(filesForArtifacts)) {
     logger.debug('updateArtifacts for updatedPackageFiles');
     const updatedPackageFileManagers = getManagersForPackageFiles(
-      updatedPackageFiles,
+      filesForArtifacts,
       managerPackageFiles,
     );
     for (const manager of updatedPackageFileManagers) {
       const packageFilesForManager = getPackageFilesForManager(
-        updatedPackageFiles,
+        filesForArtifacts,
         managerPackageFiles[manager],
       );
       sortPackageFiles(config, manager, packageFilesForManager);
