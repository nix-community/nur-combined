{
  lib,
  stdenv,
  fetchFromGitHub,
}:

stdenv.mkDerivation rec {
  pname = "gimsatul";
  version = "1.1.2";

  src = fetchFromGitHub {
    owner = "arminbiere";
    repo = "gimsatul";
    rev = "rel-${version}";
    sha256 = "sha256-Tm7IzUo9cCBKUqqRVKjNRO4KrXZTtfDsOXJR4WyS0Hc=";
  };

  doCheck = true;

  # the configure script is not generated by autotools and does not accept the
  # arguments that the default configurePhase passes like --prefix and --libdir
  dontAddPrefix = true;
  setOutputFlags = false;

  configurePhase = ''
    runHook preConfigure

    ./configure

    runHook postConfigure
  '';

  buildPhase = ''
    runHook preBuild

    make -j$NIX_BUILD_CORES
     
    runHook postBuild
  '';

  checkPhase = ''
    runHook preCheck

    make test

    runHook postCheck
  '';

  installPhase = ''
    runHook preInstall

    install -Dm0755 gimsatul "$out/bin/gimsatul"
    mkdir -p "$out/share/doc/gimsatul/"
    install -Dm0644 {LICEN?E,README*,VERSION} "$out/share/doc/gimsatul/"

    runHook postInstall
  '';

  meta = {
    description = "A portfolio style parallel SAT-solver which physically shares clauses between different solving threads.";
    mainProgram = "gimsatul";
    longDescription = ''
      This is a portfolio style parallel SAT-solver which physically shares
      clauses between different solving threads. This is made possible by using
      separate watcher data structures for each solver thread and keeping the
      actual clause data immutable. This allows to share large clauses between
      threads through atomic reference counting, which in turn allows not only
      sharing the original large (and binary) clauses but also much more
      aggressive sharing of learned clauses during the search while keeping the
      overall memory foot-print small.
    '';
    maintainers = [ (import ../../maintainer.nix { inherit (lib) maintainers; }) ];
    platforms = lib.platforms.unix;
    license = lib.licenses.mit;
    homepage = "https://github.com/arminbiere/gimsatul";
  };
}
