diff --git i/modules/caddyhttp/caddyauth/basicauth.go w/modules/caddyhttp/caddyauth/basicauth.go
index 52a5a08c..5eb8e5c2 100644
--- i/modules/caddyhttp/caddyauth/basicauth.go
+++ w/modules/caddyhttp/caddyauth/basicauth.go
@@ -56,7 +56,7 @@ type HTTPBasicAuth struct {
 	// a cache hit does not mean it is a valid password.
 	HashCache *Cache `json:"hash_cache,omitempty"`
 
-	Accounts map[string]Account `json:"-"`
+	Accounts map[string][]Account `json:"-"`
 	Hash     Comparer           `json:"-"`
 
 	// fakePassword is used when a given user is not found,
@@ -100,12 +100,8 @@ func (hba *HTTPBasicAuth) Provision(ctx caddy.Context) error {
 	repl := caddy.NewReplacer()
 
 	// load account list
-	hba.Accounts = make(map[string]Account)
+	hba.Accounts = make(map[string][]Account)
 	for i, acct := range hba.AccountList {
-		if _, ok := hba.Accounts[acct.Username]; ok {
-			return fmt.Errorf("account %d: username is not unique: %s", i, acct.Username)
-		}
-
 		acct.Username = repl.ReplaceAll(acct.Username, "")
 		acct.Password = repl.ReplaceAll(acct.Password, "")
 
@@ -126,7 +122,9 @@ func (hba *HTTPBasicAuth) Provision(ctx caddy.Context) error {
 			}
 		}
 
-		hba.Accounts[acct.Username] = acct
+		list, _ := hba.Accounts[acct.Username]
+		list = append(list, acct)
+		hba.Accounts[acct.Username] = list
 	}
 	hba.AccountList = nil // allow GC to deallocate
 
@@ -146,20 +144,25 @@ func (hba HTTPBasicAuth) Authenticate(w http.ResponseWriter, req *http.Request)
 		return hba.promptForCredentials(w, nil)
 	}
 
-	account, accountExists := hba.Accounts[username]
+	accounts, accountExists := hba.Accounts[username]
 	if !accountExists {
 		// don't return early if account does not exist; we want
 		// to try to avoid side-channels that leak existence, so
 		// we use a fake password to simulate realistic CPU cycles
-		account.password = hba.fakePassword
+		fakeAccount := Account{}
+		fakeAccount.password = hba.fakePassword
+		accounts = []Account{ fakeAccount }
 	}
 
-	same, err := hba.correctPassword(account, []byte(plaintextPasswordStr))
-	if err != nil || !same || !accountExists {
-		return hba.promptForCredentials(w, err)
+	err := (error)(nil)
+	for _, account := range accounts {
+		same := false
+		same, err = hba.correctPassword(account, []byte(plaintextPasswordStr))
+		if err == nil && same && accountExists {
+			return User{ID: username}, true, nil
+		}
 	}
-
-	return User{ID: username}, true, nil
+	return hba.promptForCredentials(w, err)
 }
 
 func (hba HTTPBasicAuth) correctPassword(account Account, plaintextPassword []byte) (bool, error) {
